- add back play duration support (I think only mplayer supports this)
  Idea being you can play each track for 1 second to easily scan them
- handle case where ffmpeg fails to encode (probably with shell magic)
  Otherwise, when creating an audiobook tool fails, it can be
  difficult to track down
- normalize audio?
- document typical use cases
   1. Combining a whole bunch of mp3 (or any format that ffmpeg supports) to a single
      .m4b file in one swoop.
   2. Doing each step manually so you can adjust the chapter list. (Note, you can also
      do use case #1, and then extract chapter list, modify it, and then set it again)
   3. Ripping an audiobook from cds only differs in that you create the input files
      (wav files) first, and then continue with the other use cases
- Add a verbose option, (ie: the user probably doesn't want to see the ffmpeg
  input output)

- implement "gen_chapter_list_from_cddbid".
  it would fetch track info from the cddb and spit out the chapters

- be able to submit tracks from chapter list to cddb?

- interactive detection of chapters via silence detection (ie: 3 seconds)
  (cutmp3 does something similar)

- Find alternative to python-cddb (or fix it).  Apparently you can't get track
  lengths from lookups.
  - http://audiotools.sourceforge.net/install.html  ?
  - freedb.py from http://bebop.bigasterisk.com/python/
  - Raw web queries? They are actually pretty simple...
    (http://ftp.freedb.org/pub/freedb/latest/CDDBPROTO)
  - command line 'cddbcmd' tool? (in ubuntu cddb 'package')

 One potential problem of just using disc ids to generate chapter
 lists is that the total cd length as reported by cddb is in seconds
 (instead of something more granular).  It would probably be a little
 bit off, and require manual adjusting.

 This doesn't matter for having the actual cds, because we get lengths
 from the real ripped audio.

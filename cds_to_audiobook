#!/usr/bin/env python

# This needs to be run in it's own temporary directory, otherwise it really clouds things up.

# ffmpeg settings
####################################################
# cd audio input settings
input_format="s16le"
input_rate="44100"
input_channels="2"

# output settings
output_bitrate="32000"
output_rate="22050"
output_channels="1"

# aac
output_codec="libfaac"
output_format="mp4"
output_extension="m4b"

## Mp3
#output_codec="libmp3lame"
#output_format="mp3"
#output_extension="ffmpeg.mp3"
####################################################

####################################################
# Lame Settings
#output_extension="lame.mp3"

lame_input_bits="16"
lame_input_rate="44.1"
lame_output_rate="22.05"

# mp3 bitrate
lame_bitrate="32"
####################################################

####################################################
## faac settings
#output_extension="default_quality.faac.m4b"
#
#faac_input_channels="2"
#faac_input_bits="16"
#faac_input_rate="44100"
#faac_output_rate="22050" # Don't think faac can downsample
#
## bitrate
#faac_bitrate="32"
####################################################

import sys
import os
import readline
import re
import time

def runOrDie(command):
    print "Running: " + command
    ret = os.system(command)
    if ret:
        print command + " failed"
        sys.exit(1)

def exitIfexists(file):
    if os.path.exists(file):
        print "%s already exists.  Exiting." % (file)
        sys.exit(1)


try:
    (script, output) = sys.argv
except:
    print ""
    print "Usage: cds_to_audiobook <title>"
    print ""
    print " Example: cds_to_audiobook BookTitle"
    print ""
    sys.exit(1)

if not os.path.exists(output):
    os.mkdir(output)

os.chdir(output)

exitIfexists("%s.%s" % (output, output_extension))

def askQuestion(question):
    print question
    answer=raw_input()
    print "answer='%s'" % answer
    return answer

count = 1

while True:

    # Use 2 digits, even for numbers less than 10 so sorting order is correct
    tmp_output = "%s-%.2d.raw" % (output, count)

    run_command = True
    if os.path.exists(tmp_output):
        answer = askQuestion("%s exists.  Overwrite or Skip? [os]" % tmp_output)

        if re.search("o", answer, re.IGNORECASE):
            run_command = True
        else:
            run_command = False

    if run_command:
        askQuestion("Insert disc %d and press <ENTER> when ready" % count)

        # Don't start until we know there's a disc in the drive
        poll_count = 0
        ret = 1
        while ret != 0:
            print "Looking for disc..."
            if poll_count > 30:
                print "Error: Could not find audio disc"
                sys.exit(1)
            ret = os.system("cdparanoia -Q 2>/dev/null")
            time.sleep(1)
            poll_count += 1

        # sleep for another 10 seconds to wait for auto insert access to calm down
        time.sleep(10)

        # -r for little endian raw
        runOrDie("cdparanoia -r 1- /dev/stdout | cat > '%s'" % (tmp_output))
        runOrDie("eject")

    count += 1

    if re.search("(n|no)", askQuestion("Continue with disk %d? [yn]" % count), re.IGNORECASE):
        break

# TODO: do we need to split aac into multiple files?  (filesize limitation for apple software? ugh...)
#  we should be able to programatically determine the max filesize

# Use ffmpeg (easier to switch formats and options) (although, files produced with it are a little bit different concerning stereo/mono)
runOrDie("(cat *.raw) | ffmpeg -y -f %s -ar %s -ac %s -i /dev/stdin -acodec %s -ar %s -ab %s -ac %s -f %s '%s.%s'" % (input_format, input_rate, input_channels, output_codec, output_rate, output_bitrate, output_channels, output_format, output, output_extension))

# TODO: add mp4 chapter support to ffmpeg.  Maybe it would be better to have this util operate on a preexisting file... ?
#  Or, should it be a separate program?  Actually, built it into ffmpeg, but do
#  another pass on the file, just in case it's hosed, and needs to be
# readjusted?  That way, you don't have to re-encode everything again to adjust the chapter marks.

# TODO: add audiobook marking support to gtkpod (supposedly works for podcasts, but not audiobooks)

#runOrDie("(cat *.raw) | lame -r -s %s --bitwidth %s --signed --little-endian --resample %s -h -m s -a --abr %s - '%s.%s'" % (lame_input_rate, lame_input_bits, lame_output_rate, lame_bitrate, output, output_extension))

# -q 80 necessary?  Looks like to down sample to 20500 we'd have to run it through a sox pipe
#  staying with stereo doesn't seem to affect filesize so much... 44.1 is a little bigger, but not significant... hrmm...
#runOrDie("(cat *.raw) | faac -R %s -B %s -C %s -X -w -b %s -o '%s.%s' -" % (faac_input_rate, faac_input_bits, faac_input_channels, faac_bitrate, output, output_extension))

# TODO: judge between all these formats...  Mainly trying to get rid of the highend hissiness

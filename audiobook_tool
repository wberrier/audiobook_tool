#!/usr/bin/env python

# Author: Wade Berrier  <wberrier@gmail.com>

# Collection of common functions and tasks when authoring audiobook files
# See the usage for more documentation

# TODO: normalize audio?

"""
# TODO: document typical use cases

1. Combining a whole bunch of mp3 (or any format that ffmpeg supports) to a single
   .m4b file in one swoop.

2. Doing each step manually so you can adjust the chapter list. (Note, you can also
   do use case #1, and then extract chapter list, modify it, and then set it again)

3. Ripping an audiobook from cds only differs in that you create the input files
   (wav files) first, and then continue with the other use cases

"""

# TODO: Add a verbose option, (ie: the user probably doesn't want to see the ffmpeg
#  input output)

####################################################
# ffmpeg output settings for combine_and_encode
output_bitrate="32000"
output_rate="22050"
output_channels="1"

# ffmpeg profiles
#  This program is focused on m4b,
#   but you can use it to encode to mp3/ogg and/or other ffmpeg codecs
ffmpeg_output_profiles = {
        '.mp3': { 'codec': 'libmp3lame', 'format': 'mp3' },
        '.m4b': { 'codec': 'libfaac',    'format': 'mp4' },
        '.ogg': { 'codec': 'libvorbis',  'format': 'ogg' },
        }
#
####################################################

####################################################
# external programs this program depends on
cmd_line_dependencies = {
        'ffmpeg': '',
        'ffplay': '',
        #'mplayer': '',
        'mp4chaps': '',
        'mp4art': '',
        'mp4tags': '',
        'mp4file': '',
        'soxi': '',
        'cdparanoia': '',
        'eject': '',
        }
#
####################################################

import sys
import os
import readline
import re
import time
import shutil
import getopt

import commands

try:
    # Keep tagpy code around for reference, but don't require it
    import tagpy
    have_tagpy = True
except:
    have_tagpy = False

class LengthRetrievalError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def lengthInSecondsTagLib(file):
    # Need a way to get the length of a file.  exiftool works,
    # Maybe tagpy as well...
    # But both only give resolution down to the second... arg
    # -> this method doesn't work on wav files

    # Hrm... taglib doesn't give milliseconds... does that matter?
    # Wow, looks like the id3 tag can specify milliseconds, bu the taglib api only reports integers?  Ugh...

    if not have_tagpy:
        raise LengthRetrievalError("tagpy not available")

    try:
        f = tagpy.FileRef(file)
        seconds = f.audioProperties().length
    except:
        raise LengthRetrievalError("tagpy: unknown file type")

    # Sometimes library says there's invalid sample rates... yet upon printing them, they seem fine.  What gives?
    #print "Sample rate: " + str(f.audioProperties().sampleRate)
    return float(seconds)

def convertToWavMplayer(file):
    """Returns new wav file, which the user is responsible for cleaning up"""

    wavFile = file + ".wav"
    # Convert it if we haven't done so already
    if not os.path.exists(wavFile):
        status, output = commands.getstatusoutput("mplayer '%s' -ao 'pcm:file=%s'" % (file, wavFile))

    return wavFile

mplayer_duration_re = re.compile("ID_LENGTH=(.*)")
def lengthInSecondsMplayer(file):
    """Will convert non-wav files to wav to get a more accurate reading, but still not as accurate as what ffmpeg reports"""
    # mplayer method

    convertToWav = False
    if os.path.splitext(file)[1] != ".wav":
        convertToWav = True

    if convertToWav:
        file = convertToWavMplayer(file)

    # This probably reports in milliseconds, since it appears to just get the length
    # Hacky, yes... but it appears gives us milliseconds
    #  -> Actually it doesn't seem to give milliseconds
    status, output = commands.getstatusoutput("mplayer -vo null -ao null -identify -frames 0 '%s'" % file)

    try:
        (seconds,) = mplayer_duration_re.search(output, re.MULTILINE).groups()
    except(AttributeError):
        raise LengthRetrievalError("Failed to parse: " + output)

    if convertToWav:
        # Clean up... (much faster to clean up each file than to leave them around (yay kernel disk cache))
        os.unlink(file)

    # str->float
    return float(seconds)

def convertToWavFFmpeg(file):
    """Returns new wav file, which the user is responsible for cleaning up"""

    wavFile = file + ".wav"
    # Convert it if we haven't done so already
    if not os.path.exists(wavFile):
        status, output = commands.getstatusoutput("ffmpeg -y -i '%s' -f wav '%s' " % (file, wavFile))

    return wavFile

ffplay_duration_re = re.compile("Duration: (\d\d):(\d\d):(\d\d).(\d\d),")
def lengthInSecondsFFplay(file):
    """Get the length of a file, based on ffplay.  Hundredths of a second accuracy.  (more precision than mplayer and taglib)
       Even though it gives more precision, it doesn't make the chapter marks any more accurate (if anything, they are worse!)

       Converting mp3s to a .wav file is pretty accurate (hundredths).  Much more accurate than doing the equivalent with mplayer.

       For audiobooks from cds, we don't do an unnecessary conversion here, since those will be wav files
    """

    convertToWav = False
    if os.path.splitext(file)[1] != ".wav":
        convertToWav = True

    if convertToWav:
        file = convertToWavFFmpeg(file)

    status, output = commands.getstatusoutput("ffplay -stats -vn -an '%s' " % file)

    try:
        (hours, minutes, seconds, decimal) = ffplay_duration_re.search(output, re.MULTILINE).groups()
    except:
        raise LengthRetrievalError("Failed to parse: " + output)

    total_seconds = totalSeconds(hours, minutes, seconds, decimal)

    if convertToWav:
        # Clean up... (much faster to clean up each file than to leave them around (yay kernel disk cache))
        os.unlink(file)

    #  Tried rounding this... but it still gave different results than mplayer
    return float(total_seconds)

# Interesting bits:
#Sample Rate    : 22050
#Duration       : 00:04:51.92 = 6436800 samples ~ 21893.9 CDDA sectors
#soxi_duration_re = re.compile("Sample Rate\s+: (\d+).*Duration\s+: \d\d:\d\d:\d\d\.\d\d = (\d+) samples")
# Fine, break into two regexes, since I can't seem to match both in one pass (even with re.DOTALL)
soxi_sample_rate_re = re.compile("Sample Rate\s+: (\d+)")
soxi_duration_re = re.compile("Duration\s+: \d\d:\d\d:\d\d\.\d\d = (\d+) samples")
def lengthInSecondsSoxi(file):
    """
    First, convert the file to a wav file, and then, using the sample rate, get the duration to the thousandths

    This method is the most accurate.  Otherwise, with the ffplay method (even when converting to wav!) with a book
    with 240 chapters, a full second discrepancy crept in.

    Note: soxi does report getting the number of samples from .mp3 and other various non-wav formats, but it doesn't
    appeart to be quite as accurate.  Even though converting to wav is slow and cumbersome, it still seems to be the
    most accurate.

    Using ffmpeg to both convert to wav and to encode could also be contributing to the accuracy.  Different results
    are gotten when using mplayer to convert to a wav file (header info, or actual file output? Not sure...)
    """

    convertToWav = False
    if os.path.splitext(file)[1] != ".wav":
        convertToWav = True

    if convertToWav:
        file = convertToWavFFmpeg(file)
        #file = convertToWavMplayer(file)

    status, output = commands.getstatusoutput("soxi '%s' " % file)

    try:
        (sample_rate,) = soxi_sample_rate_re.search(output).groups()
        (num_samples,) = soxi_duration_re.search(output).groups()
    except:
        raise LengthRetrievalError("Failed to parse: " + output)

    seconds = float(num_samples) / float(sample_rate)

    if convertToWav:
        # Clean up... (much faster to clean up each file than to leave them around (yay kernel disk cache))
        os.unlink(file)

    return float(seconds)

# TODO: method that manually parses wav header . we'd also have to know the specs from the wav header... ugh
#   but still, ffmpeg method only gives hundredths, where having thousandsth would help
#   (one hundred of a second rounding for a hundred chapters: could be 1 second off!)
# -> shelling out to soxi is probably sufficient

def runOrDie(command):
    print "Running: " + command
    ret = os.system(command)
    if ret:
        print command + " failed"
        sys.exit(1)

def askQuestion(question):
    print question
    answer=raw_input()
    print "answer='%s'" % answer
    return answer

def exitIfMissing(filename):
    if not os.path.exists(filename):
        print "Error: file does not exist: " + filename
        sys.exit(1)

class Chapter:
    def __init__(self, timeMark, name):
        self.timeMark = timeMark
        self.name = name

    @classmethod
    def fromLine(cls, line):
        """Factory method for creating a chapter based on the text format"""

        (hours, minutes, seconds, milliseconds, chapter_name) = chapter_line_re.search(line).groups()
        total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

        obj = cls(total_seconds, chapter_name)
        return obj

    @classmethod
    def fromExportedLine(cls, line):
        """
        Factory method for creating a chapter based on the exported text format from mp4chap
        Chapter #030 - 19:00:40.111 - "Chapter 30"
        """

        (hours, minutes, seconds, milliseconds, chapter_name) = mp4chap_exported_chapter_line_re.search(line).groups()
        total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

        obj = cls(total_seconds, chapter_name)
        return obj

    def toString(self):
        # Takes a decimal

        total_seconds = int(self.timeMark)
        hours = total_seconds / 3600
        minutes = (total_seconds - (hours * 3600)) / 60
        seconds = (total_seconds - (hours * 3600) - (minutes * 60))

        # Round the decimal to 3 places (since that's all the chapter format accounts for)
        decimal = round(self.timeMark - total_seconds, 3)

        # Get the float to 3 places, and grab everything after the decimal
        milliseconds_string = ("%0.3f" % decimal).split('.')[1]

        return "%02d:%02d:%02d.%s %s" % (hours, minutes, seconds, milliseconds_string, self.name)

def totalSeconds(hours, minutes, seconds, decimal):

    total_seconds = 0.0
    total_seconds += float(hours) * float(3600) + float(minutes) * 60 + float(seconds) + float("0.%s" % decimal)

    return total_seconds

chapter_line_re = re.compile("(\d\d):(\d\d):(\d\d).(\d\d\d) (.*)")
mp4chap_exported_chapter_line_re = re.compile("\tChapter #\d\d\d - (\d\d):(\d\d):(\d\d).(\d\d\d) - \"(.*)\"")

class ChapterList:
    def __init__(self):
        self.chapters = []
        self.currentTimeMark = 0.0

    @classmethod
    def fromFile(cls, filename):
        """Parse filename to populate the chapter info"""

        obj = cls()

        fd = open(filename)
        for line in fd.readlines():
            obj.addChapter(Chapter.fromLine(line))
        fd.close()

        return obj

    @classmethod
    def fromM4bFile(cls, filename):
        """Export chapters via mp4chaps and format to the expected import format"""

        obj = cls()

        no_chapters_re = re.compile("File .* does not contain chapters of type QuickTime and Nero")

        (status, output) = commands.getstatusoutput("mp4chaps --list '%s'" % filename)

        # Check for empty chapter
        if no_chapters_re.search(output):
            return obj

        count = -1
        for line in output.split("\n"):
            count += 1
            if count == 0:
                continue
            obj.addChapter(Chapter.fromExportedLine(line))

        return obj

    def getChapter(self, chapterIndex):
        if not (chapterIndex > 0 and chapterIndex <= len(self.chapters)):
            print "Error: invalid chapter: %d" % chapterIndex
            sys.exit(1)

        return self.chapters[chapterIndex - 1]

    def addChapter(self, chapter):
        self.chapters.append(chapter)
        self.currentTimeMark = chapter.timeMark

    def addChapterFromFile(self, filename):

        name = os.path.splitext(filename)[0]
        self.chapters.append(Chapter(self.currentTimeMark, name))

        try:
            # Update the cumalative time
            # These give different results!  Interesting...  Wonder which one is accurate?
            #  We'll probably need manual adjustment, so maybe it doesn't matter
            #self.currentTimeMark += lengthInSecondsMplayer(filename)
            #self.currentTimeMark += lengthInSecondsTagLib(filename)
            #self.currentTimeMark += lengthInSecondsFFplay(filename)
            self.currentTimeMark += lengthInSecondsSoxi(filename)
        except(LengthRetrievalError):
            print "Error reading file: " + filename
            sys.exit(1)

    def adjustChapterTimeMark(self, chapterIndex, adjustNumSeconds, cascade=False):
        """Easily adjust chapter markings, optionally adjusting each successive chapter
        adjustNumSeconds can be a fractional positive or negative
        """

        # For all of the chapters (+1 for the range function)
        for i in range(chapterIndex, len(self.chapters) + 1):
            self.getChapter(i).timeMark += adjustNumSeconds

            # Only do one chapter, or do all the rest?
            if not cascade:
                break

    def toString(self):
        """Get Whole chapter listing in mp4chap import/export format"""
        ret = ""
        for c in self.chapters:
            ret += c.toString() + "\n"
        return ret

    def toFile(self, filename):
        """Write out the chapters to a file"""
        fd = open(filename, 'w')
        fd.write(self.toString())
        fd.close()


# Rip an audiobook consisting of multiple cds to wav files, one per track per disc

# Then, use the combine_and_encode to encode to a single audiobook

# Optionally use gen_chapter_list to generate chapter information for m4b files, injected with set_chapters

# This needs to be run in it's own temporary directory, otherwise it really clouds things up.

def interactivelyRipCds(output):

    if not os.path.exists(output):
        os.mkdir(output)
    os.chdir(output)

    count = 1

    while True:

        # Use 2 digits, even for numbers less than 10 so sorting order is correct
        tmp_output = "%s-%.2d.wav" % (output, count)

        run_command = True
        if os.path.exists(tmp_output):
            answer = askQuestion("%s exists.  Overwrite or Skip? [os]" % tmp_output)

            if re.search("o", answer, re.IGNORECASE):
                run_command = True
            else:
                run_command = False

        if run_command:
            askQuestion("Insert disc %d and press <ENTER> when ready" % count)

            # Don't start until we know there's a disc in the drive
            poll_count = 0
            ret = 1
            while ret != 0:
                print "Looking for disc..."
                if poll_count > 30:
                    print "Error: Could not find audio disc"
                    sys.exit(1)
                ret = os.system("cdparanoia -Q 2>/dev/null")
                time.sleep(1)
                poll_count += 1

            # sleep for another 10 seconds to wait for auto insert access to calm down
            time.sleep(10)

            # Rip the whole disc to a wav file
            runOrDie("cdparanoia --output-wav 1- '%s'" % (tmp_output))
            runOrDie("eject")

        count += 1

        if re.search("(n|no)", askQuestion("Continue with disk %d? [yn]" % count), re.IGNORECASE):
            break


# generate a chapter listing to stdout that can be imported via mp4chaps

# The idea is to get a generated listing, and then hack up the file,
# and then use mp4chaps to import to a file created with files_to_audiobooks

# Format: 00:00:00.000 Chapter 1
# TODO: break up chapter lists for resulting m4b files over the sample limit
def genChapterList(files, out_file=""):

    # sort the files, just in case
    files.sort()

    cl = ChapterList()

    for f in files:
        print "Adding file to chapter list: " + f
        cl.addChapterFromFile(f)

    if len(out_file) > 0:
        cl.toFile(out_file)

    return cl

def buildFilesString(files):
    ret = ""
    for f in files:
        ret += " '%s'" % f
    return ret

def getFFmpegInputFormatOptions(args):
    ffmpeg_input_format_options = ""
    opts, remaining_args = getopt.gnu_getopt(args, "", [ "ffmpeg_input_format_options=" ])
    for option, value in opts:
        if option == "--ffmpeg_input_format_options":
            ffmpeg_input_format_options = value
    args = remaining_args
    return (ffmpeg_input_format_options, args)

# Combines a bunch of audio files to a single mp3, m4b, or ogg audiobook
#  Supports any audio files supported by ffmpeg
#  Do this in one pass to avoid a path using intermediate files going to wav, raw, and then output
#  There is a lossy conversion, but for an audiobook, oh well...

# TODO: warn user if outputting to m4b file will have over
#  2 billion samples, or whatever the ipod limitation is... ugh
#  http://groups.google.com/group/macvisionaries/msg/f4acb49721b51834
#  could split files at known boundary to avoid the problem
#  2 bil / 22050 samples = 194783 seconds
#  = 54 hours.  Is that really our maximum?  Should be fine for most books... ?
#  -> roughly 775 m4b file is the maximum
#  Or is it 4 billion / 22050 = 108 hours?
#  -> 64:43 book had problems.  Chapters appeared fine, but iphone ipod app crashed
#     when it tried to play it (or scroll the chapters)

# TODO: incorporate gen_chapter_list for m4b files that must be broken up
def combineAndEncode(output, in_files, ffmpeg_input_options=""):

    for f in in_files:
        exitIfMissing(f)

    # Get output file extension
    output_extension = os.path.splitext(output)[1]

    if not ffmpeg_output_profiles.has_key(output_extension):
        print "Error: unknown resulting file format: " + output_extension
        sys.exit(1)

    # Pick ffmpeg output parameters based on output filetype
    output_codec = ffmpeg_output_profiles[output_extension]['codec']
    output_format = ffmpeg_output_profiles[output_extension]['format']

    error_filename = "/tmp/audiobook_tool_error.%s" % os.getpid()

    # Command to loop through all the input files and output to stdout
    #  Use the output rate and channels to cut down on conversions
    #  (note: a fifo was attempted, but the fifo would randomly close prematurely)
    #  Use a tmp file to carry the error code through the pipe
    intermediate_format_options = "-ar %s -ac %s -f s16le" % (output_rate, output_channels)
    # TODO: gather length by converting to a wav, getting the size via sox, piping with ffmpeg, and then cleaning up the wav file?
    #  that "could" be faster overall, even though it would slow down this step (writing each wav file to disc)
    player_command = "for i in %s ; do ffmpeg -y %s /dev/stdout %s -i \"$i\" || { echo '' >&2; echo \"****** Failed to play $i ******\" >&2 ; echo '' >&2 ; touch %s ; exit 1 ; } ; done""" % (buildFilesString(in_files), intermediate_format_options, ffmpeg_input_options, error_filename)

    # Now run the command to convert all data coming from stdin
    output_format_options = "-acodec %s -ar %s -ab %s -ac %s -f %s" % (output_codec, output_rate, output_bitrate, output_channels, output_format)
    runOrDie("rm -f %s ; ( %s ) | ffmpeg -v 0 -y %s -i /dev/stdin %s '%s'" % (error_filename, player_command, intermediate_format_options, output_format_options, output))

    if os.path.exists(error_filename):
        print ""
        print "Failed to decode input files!"
        print ""
        print "Suggestion: specify ffmpeg input options with '--ffmpeg_input_format_options'"
        print ""
        print "  Note: these options will be applied to _all_ input files"
        print ""
        print "Suggestion 2: try manually converting that one file with another tool to a .wav file and use it to replace the broken input file"
        print ""
        print "  ie: mplayer <file unreadable by ffmpeg> -ao pcm:file=tmp.wav; ffmpeg -y -i tmp.wav -f wav out.wav"
        print ""
        print "  Doing the second conversion with ffmpeg probably won't make a difference except for the paranoid"
        print ""
        os.unlink(error_filename)
        sys.exit(1)

    print "Success!"

def playChapterSample(chapter_txt, audio_file, chapter_index, offset=0.0):
    """Easily play at a spot in a chapter to assist in verifying all chapter marks"""

    exitIfMissing(chapter_txt)
    exitIfMissing(audio_file)

    chapter = ChapterList.fromFile(chapter_txt).getChapter(chapter_index)

    # is mplayer accurate when it comes to seeking? (ie: does it match seeking with chapters with Apple's software?)
    #  -> doing some rough checks, it appears to match quicktime on windows

    #  Documentation says it only seeks to second boundaries, but seeking to fractional seconds works
    print "Playing chapter %d (%s)" % (chapter_index, chapter.name)

    # Different methods to play the file
    #runOrDie("mplayer -ss %.3f '%s'" % (chapter.timeMark + offset, audio_file))
    runOrDie("ffplay -ss %.3f %s" % (chapter.timeMark + offset, audio_file))


def adjustChapter(chapter_txt, chapter_index, seconds):

    exitIfMissing(chapter_txt)

    cl = ChapterList.fromFile(chapter_txt)

    cl.adjustChapterTimeMark(chapter_index, seconds, cascade)

    cl.toFile(chapter_txt)

def setChapters(audio_file, chapter_txt):

    exitIfMissing(chapter_txt)
    exitIfMissing(audio_file)

    # Remove all chapters
    #  (fails if list doesn't exist... oh well)
    os.system("mp4chaps --remove '%s'" % audio_file)

    # Put correct chapter file in place if needs be, and clean up afterwards
    #  (TODO: if mp4v2 every gets python bindings, we won't have to do this kind of work around)
    tool_expected_chapter_file = output_extension = os.path.splitext(audio_file)[0] + ".chapters.txt"
    cleanup = False
    if tool_expected_chapter_file != chapter_txt:
        shutil.copyfile(chapter_txt, tool_expected_chapter_file)
        cleanup = True

    # Inject chapters
    runOrDie("mp4chaps --import '%s'" % (audio_file))

    if cleanup:
        os.unlink(tool_expected_chapter_file)

def getChapters(audio_file, chapter_txt):

    exitIfMissing(audio_file)

    cl = ChapterList.fromM4bFile(audio_file)

    cl.toFile(chapter_txt)

def setMetaData(audio_file, author, title, trackTitle=""):

    exitIfMissing(audio_file)

    # Set track title to title if no track title was passed in
    if trackTitle == "":
        trackTitle = title

    # Set author and title (TODO: more info?)
    #  Use double quotes so apostraphes can be used in titles
    # Itunes audiobooks uses the album as the top level tree, and then the title in the subtree.
    #  TODO: maybe have optional title (song) for when books must be split into two
    runOrDie("mp4tags -artist \"%s\" -album \"%s\" -song \"%s\" \"%s\"" % (author, title, trackTitle, audio_file))

def setCoverArt(audio_file, image_file):

    exitIfMissing(audio_file)
    exitIfMissing(image_file)

    # Set/Replace Coverart
    # (fails if no art is set... oh well)
    os.system("mp4art --remove '%s'" % (audio_file))
    runOrDie("mp4art --add '%s' '%s'" % (image_file, audio_file))

def optimizeMp4(audio_file):

    exitIfMissing(audio_file)

    # Optimize
    #  TODO: what does this really do?
    runOrDie("mp4file --optimize '%s'" % (audio_file))


def m4bFromFiles(audio_file, author, title, art_file, in_files, ffmpeg_input_format_options=""):
    """All-in-one method to generate a book once all the necessary information is given."""

    # Get the chapter name
    chapter_txt = os.path.splitext(audio_file)[0] + "chapters.txt"

    cl = genChapterList(in_files, chapter_txt)

    # TODO: break up the chapter lists and combining/encoding if it exceeds the m4b max sample count

    combineAndEncode(audio_file, in_files, ffmpeg_input_format_options)

    setChapters(audio_file, chapter_txt)
    setMetaData(audio_file, author, title)
    setCoverArt(audio_file, art_file)
    optimizeMp4(audio_file)

    print "Success!"


def validateDependencies(progs):

    for p in progs:
        (status, output) = commands.getstatusoutput("which " + p)
        if len(output) == 0:
            print "Warning: %s not found" % p

def usage():
    usage_text="""
./audiobook_tool <sub command> <sub command arguments>

 Sub commands:

  rip_cds             <output dir>
  combine_and_encode  <AudioBook.[mp3|m4b|ogg]> <ffmpeg recognizable audio files> [--ffmpeg_input_format_options="options"]

  gen_chapter_list    <AudioBook.chapters.txt> <audio files>
  play_chapter        <AudioBook.chapters.txt> <AudioBook.m4b> <chapter index> [offset]
  adjust_chapter      <AudioBook.chapters.txt> <chapter index> [--cascade] <[-]seconds>

  set_chapters        <AudioBook.m4b> <AudioBook.chapters.txt>
  get_chapters        <AudioBook.m4b> <AudioBook.chapters.txt>
  set_metadata        <AudioBook.m4b> <Author> <Title> [Track Title]
  set_coverart        <AudioBook.m4b> <coverart image>
  optimize            <AudioBook.m4b>

  m4b_from_files      <AudioBook.m4b> <Author> <Title> <coverart image> <ffmpeg recognizable audio files> [--ffmpeg_input_format_options="options"]

"""
    print usage_text



if __name__ == "__main__":

    # Check for command line dependencies (only warn user)
    validateDependencies(cmd_line_dependencies.keys())

    try:
        subcommand = sys.argv[1]
        subcommand_args = sys.argv[2:]
    except:
        usage()
        sys.exit(1)

    # Parse and handle each of the sub-commands
    #  TODO: more elegant way to parse all of this?
    if 'rip_cds' == subcommand:
        try:
            output = subcommand_args[0]
        except:
            usage()
            sys.exit(1)

        interactivelyRipCds(output)

    elif 'combine_and_encode' == subcommand:

        (ffmpeg_input_format_options, subcommand_args) = getFFmpegInputFormatOptions(subcommand_args)

        try:
            output = subcommand_args[0]
            in_files = subcommand_args[1:]

            if len(in_files) < 1:
                raise
        except:
            usage()
            sys.exit(1)

        combineAndEncode(output, in_files, ffmpeg_input_format_options)

    elif 'gen_chapter_list' == subcommand:
        try:
            out_file = subcommand_args[0]
            files = subcommand_args[1:]

            if len(files) < 1:
                raise

        except:
            usage()
            sys.exit(1)

        genChapterList(files, out_file)

    elif 'play_chapter' == subcommand:

        # Get optional offset
        offset = 0.0
        if len(subcommand_args) == 4:
            offset = float(subcommand_args[3])
            subcommand_args.pop()

        try:
            (chapter_txt, audio_file, chapter_index) = subcommand_args
            chapter_index = int(chapter_index)
        except:
            usage()
            sys.exit(1)

        playChapterSample(chapter_txt, audio_file, chapter_index, offset)

    elif 'adjust_chapter' == subcommand:

        cascade = False
        for arg in subcommand_args:
            if arg == "--cascade":
                cascade = True
                subcommand_args.remove(arg)

        try:
            (chapter_txt, chapter_index, seconds) = subcommand_args
            chapter_index = int(chapter_index)
            seconds = float(seconds)
        except:
            usage()
            sys.exit(1)

        adjustChapter(chapter_txt, chapter_index, seconds)

    elif 'set_chapters' == subcommand:
        try:
            (audio_file, chapter_txt) = subcommand_args
        except:
            usage()
            sys.exit(1)

        setChapters(audio_file, chapter_txt)

    elif 'get_chapters' == subcommand:
        try:
            (audio_file, chapter_txt) = subcommand_args
        except:
            usage()
            sys.exit(1)

        getChapters(audio_file, chapter_txt)

    elif 'set_metadata' == subcommand:
        # Get optional offset
        trackTitle = ""
        if len(subcommand_args) == 4:
            trackTitle = subcommand_args[3]
            subcommand_args.pop()

        try:
            (audio_file, author, title) = subcommand_args
        except:
            usage()
            sys.exit(1)

        setMetaData(audio_file, author, title, trackTitle)

    elif 'set_coverart' == subcommand:
        try:
            (audio_file, image_file) = subcommand_args
        except:
            usage()
            sys.exit(1)

        setCoverArt(audio_file, image_file)

    elif 'optimize' == subcommand:
        try:
            (audio_file,) = subcommand_args
        except:
            usage()
            sys.exit(1)

        optimizeMp4(audio_file)

    elif 'm4b_from_files' == subcommand:

        # Get optional arguments
        (ffmpeg_input_format_options, subcommand_args) = getFFmpegInputFormatOptions(subcommand_args)

        try:
            audio_file = subcommand_args[0]
            author     = subcommand_args[1]
            title      = subcommand_args[2]
            art_file   = subcommand_args[3]
            in_files   = subcommand_args[4:]
        except:
            usage()
            sys.exit(1)

        m4bFromFiles(audio_file, author, title, art_file, in_files, ffmpeg_input_format_options)

    else:
        usage()
        sys.exit(1)

    sys.exit(0)


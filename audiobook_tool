#!/usr/bin/env python

# Author: Wade Berrier  <wberrier@gmail.com>

# License: GPLv2

# Collection of common functions and tasks when authoring audiobook files
# See the usage for more documentation

####################################################
# ffmpeg output settings for combine_and_encode
output_bitrate="32000"
output_rate="22050"
output_channels="1"

# ffmpeg profiles
#  This program is focused on m4b,
#   but you can use it to encode to mp3/ogg and/or other ffmpeg codecs
ffmpeg_output_profiles = {
        '.mp3': { 'codec': 'libmp3lame', 'format': 'mp3' },
        '.m4b': { 'codec': 'libfaac',    'format': 'mp4' },
        '.ogg': { 'codec': 'libvorbis',  'format': 'ogg' },
        }
#
####################################################

####################################################
# external programs this program depends on
cmd_line_dependencies = {
        'ffmpeg': '',
        #'ffplay': '',
        'mplayer': '',
        'mp4chaps': '',
        'mp4art': '',
        'mp4tags': '',
        'mp4file': '',
        'mp4info': '',
        'soxi': '',
        'sox': '', # needed for tempo
        'cdparanoia': '',
        'eject': '',
        'wc': '', # needed to compute input length
        }
#
####################################################

import sys
import os
import readline
import re
import time
import shutil
import getopt
import CDDB
import DiscID
import glob

import commands

try:
    # Keep tagpy code around for reference, but don't require it
    import tagpy
    have_tagpy = True
except:
    have_tagpy = False

def shellQuote(str):
    return "'" + str.replace("'", "'\\''") + "'"

class LengthRetrievalError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class WavConversionError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def lengthInSecondsTagLib(file):
    # Need a way to get the length of a file.  exiftool works,
    # Maybe tagpy as well...
    # But both only give resolution down to the second... arg
    # -> this method doesn't work on wav files

    # Hrm... taglib doesn't give milliseconds... does that matter?
    # Wow, looks like the id3 tag can specify milliseconds, bu the taglib api only reports integers?  Ugh...

    if not have_tagpy:
        raise LengthRetrievalError("tagpy not available")

    try:
        f = tagpy.FileRef(file)
        seconds = f.audioProperties().length
    except:
        raise LengthRetrievalError("tagpy: unknown file type")

    # Sometimes library says there's invalid sample rates... yet upon printing them, they seem fine.  What gives?
    #print "Sample rate: " + str(f.audioProperties().sampleRate)
    return float(seconds)

def convertToWavMplayer(file):
    """Returns new wav file, which the user is responsible for cleaning up"""

    wavFile = file + ".wav"
    # Convert it if we haven't done so already
    if not os.path.exists(wavFile):
        status, output = commands.getstatusoutput("mplayer %s -ao pcm:file=%s" % (shellQuote(file), shellQuote(wavFile)))

    return wavFile

mplayer_duration_re = re.compile("ID_LENGTH=(.*)")
def lengthInSecondsMplayer(file):
    """Will convert non-wav files to wav to get a more accurate reading, but still not as accurate as what ffmpeg reports"""
    # mplayer method

    convertToWav = False
    if os.path.splitext(file)[1] != ".wav":
        convertToWav = True

    if convertToWav:
        file = convertToWavMplayer(file)

    # This probably reports in milliseconds, since it appears to just get the length
    # Hacky, yes... but it appears gives us milliseconds
    #  -> Actually it doesn't seem to give milliseconds
    status, output = commands.getstatusoutput("mplayer -vo null -ao null -identify -frames 0 %s" % shellQuote(file))

    try:
        (seconds,) = mplayer_duration_re.search(output, re.MULTILINE).groups()
    except(AttributeError):
        raise LengthRetrievalError("Failed to parse: " + output)

    if convertToWav:
        # Clean up... (much faster to clean up each file than to leave them around (yay kernel disk cache))
        os.unlink(file)

    # str->float
    return float(seconds)

def convertToWavFFmpeg(file, tempo="1.0"):
    """Returns new wav file, which the user is responsible for cleaning up

    Optionally takes a tempo arg, in which the file is first run through a sox pipe

    """

    # Store the tempo in the filename for correct caching purposes
    wavFile = file + "_" + tempo + ".wav"

    # Run through a sox pipe if we want to change the tempo
    #  Note: have sox write out the wav file, should be accurate, as ffmpeg is doing the decoding
    if tempo != "1.0":
        sox_cmd = "sox -L -t s16 -r %s -c %s - %s tempo %s 30" % (output_rate, output_channels, shellQuote(wavFile), tempo)
        intermediate_format_options = "-ar %s -ac %s -f s16le" % (output_rate, output_channels)
        command = "ffmpeg -v 0 -y %s /dev/stdout -i %s | %s" % (intermediate_format_options, shellQuote(file), sox_cmd)

    # Normal conversion without the sox pipe
    else:
        command = "ffmpeg -y -i %s -f wav %s" % (shellQuote(file), shellQuote(wavFile))

    # Convert it if we haven't done so already
    if not os.path.exists(wavFile):
        status, output = commands.getstatusoutput(command)
        if status:
            print output
            raise WavConversionError("Unable to convert file to .wav: " + file)

    return wavFile

def lengthInSecondsFFmpeg(file, tempo="1.0"):
    """Decode input using ffmpeg to determine the length of the input

    Optionally takes a tempo arg, in which the file is first run through a sox pipe

    """

    wc_cmd = "wc --bytes"
    ffmpeg_decode_cmd = "ffmpeg -v 0 -y -i %s -acodec pcm_s16le -f s16le -ar %s -ac %s /dev/stdout 2>/dev/null" % (shellQuote(file), output_rate, output_channels)
    # Run through a sox pipe if we want to change the tempo
    #  Note: have sox write out to stdout, and count with wc.  Should be accurate, as ffmpeg is doing the decoding
    if tempo != "1.0":
        sox_cmd = "sox -L -t s16 -r %s -c %s - -t s16 -r %s -c %s - tempo %s 30" % (output_rate, output_channels, output_rate, output_channels, tempo)
        command = "%s | %s | %s" % (ffmpeg_decode_cmd, sox_cmd, wc_cmd)

    # Normal decode without the sox pipe
    else:
        command = "%s | %s" % (ffmpeg_decode_cmd, wc_cmd)

    status, output = commands.getstatusoutput(command)
    # If there was a return code error, or we counted 0 bytes -> error
    if status or output == "0":
        print output
        raise WavConversionError("Unable to convert file to .wav: " + file)

    return float(output)/(float(output_rate)*float(output_channels)*2.0) # 2 because 16 bits per sample, or 2 bytes per sample

# Interesting bits:
#Sample Rate    : 22050
#Duration       : 00:04:51.92 = 6436800 samples ~ 21893.9 CDDA sectors
#soxi_duration_re = re.compile("Sample Rate\s+: (\d+).*Duration\s+: \d\d:\d\d:\d\d\.\d\d = (\d+) samples")
# Fine, break into two regexes, since I can't seem to match both in one pass (even with re.DOTALL)
soxi_sample_rate_re = re.compile("Sample Rate\s+: (\d+)")
soxi_duration_re = re.compile("Duration\s+: \d\d:\d\d:\d\d\.\d\d = (\d+) samples")
def lengthInSecondsSoxi(file, tempo="1.0"):
    """
    Use soxi to determine wave file lengths, and ffmpeg decoding for all others.

    Using ffmpeg to both convert to wav and to encode could also be contributing to the accuracy.  Different results
    are gotten when using mplayer to convert to a wav file (header info, or actual file output? Not sure...)
    """

    decodeRequired = False
    if os.path.splitext(file)[1] != ".wav" or tempo != "1.0":
        decodeRequired = True

    if decodeRequired:
        seconds = lengthInSecondsFFmpeg(file, tempo)
    else:
        status, output = commands.getstatusoutput("soxi %s" % shellQuote(file))

        try:
            (sample_rate,) = soxi_sample_rate_re.search(output).groups()
            (num_samples,) = soxi_duration_re.search(output).groups()
        except:
            raise LengthRetrievalError("Failed to parse: " + output)
        seconds = float(num_samples) / float(sample_rate)
        # TODO: check to see if "seconds = float(num_samples) / (float(sample_rate) * float(tempo))"
        #       would suffice instead of sending the wave file through sox when a tempo is given

    return float(seconds)

# TODO: method that manually parses wav header . we'd also have to know the specs from the wav header... ugh
#   but still, ffmpeg method only gives hundredths, where having thousandsth would help
#   (one hundred of a second rounding for a hundred chapters: could be 1 second off!)
# -> shelling out to soxi is probably sufficient

def runOrDie(command, error_message=""):
    print "Running: " + command
    ret = os.system(command)
    if ret:
        print command + " failed"
        if len(error_message):
            print "Error: " + error_message
        sys.exit(1)

def askQuestion(question):
    print question
    answer=raw_input()
    print "answer='%s'" % answer
    return answer

def exitIfMissing(filename):
    if not os.path.exists(filename):
        print "Error: file does not exist: " + filename
        sys.exit(1)

class Chapter:
    def __init__(self, timeMark, name):
        self.timeMark = timeMark
        self.name = name

    @classmethod
    def fromLine(cls, line):
        """Factory method for creating a chapter based on the text format"""

        (hours, minutes, seconds, milliseconds, chapter_name) = chapter_line_re.search(line).groups()
        total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

        obj = cls(total_seconds, chapter_name)
        return obj

    @classmethod
    def fromExportedLine(cls, line):
        """
        Factory method for creating a chapter based on the exported text format from mp4chap
        Chapter #030 - 19:00:40.111 - "Chapter 30"
        """

        (hours, minutes, seconds, milliseconds, chapter_name) = mp4chap_exported_chapter_line_re.search(line).groups()
        total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

        obj = cls(total_seconds, chapter_name)
        return obj

    def adjustTempo(self, tempo):
        """Compute new chapter mark based on new tempo"""
        self.timeMark /= float(tempo)

    def toString(self):
        # Takes a decimal

        total_seconds = int(self.timeMark)
        hours = total_seconds / 3600
        minutes = (total_seconds - (hours * 3600)) / 60
        seconds = (total_seconds - (hours * 3600) - (minutes * 60))

        # Round the decimal to 3 places (since that's all the chapter format accounts for)
        decimal = round(self.timeMark - total_seconds, 3)

        # Get the float to 3 places, and grab everything after the decimal
        milliseconds_string = ("%0.3f" % decimal).split('.')[1]

        return "%02d:%02d:%02d.%s %s" % (hours, minutes, seconds, milliseconds_string, self.name)

def totalSeconds(hours, minutes, seconds, decimal):

    total_seconds = 0.0
    total_seconds += float(hours) * float(3600) + float(minutes) * 60 + float(seconds) + float("0.%s" % decimal)

    return total_seconds

chapter_line_re = re.compile("(\d\d):(\d\d):(\d\d).(\d\d\d) (.*)")
mp4chap_exported_chapter_line_re = re.compile("\tChapter #\d\d\d - (\d\d):(\d\d):(\d\d).(\d\d\d) - \"(.*)\"")

class ChapterList:
    def __init__(self):
        self.chapters = []
        self.currentTimeMark = 0.0

    @classmethod
    def fromFile(cls, filename):
        """Parse filename to populate the chapter info"""

        obj = cls()

        fd = open(filename)
        for line in fd.readlines():
            obj.addChapter(Chapter.fromLine(line))
        fd.close()

        return obj

    @classmethod
    def fromM4bFile(cls, filename):
        """Export chapters via mp4chaps and format to the expected import format"""

        obj = cls()

        no_chapters_re = re.compile("File .* does not contain chapters of type QuickTime and Nero")

        (status, output) = commands.getstatusoutput("mp4chaps --list %s" % shellQuote(filename))

        # Check for empty chapter
        if no_chapters_re.search(output):
            return obj

        count = -1
        for line in output.split("\n"):
            count += 1
            if count == 0:
                continue
            obj.addChapter(Chapter.fromExportedLine(line))

        return obj

    def getChapter(self, chapterIndex):
        if not (chapterIndex > 0 and chapterIndex <= len(self.chapters)):
            print "Error: invalid chapter: %d" % chapterIndex
            sys.exit(1)

        return self.chapters[chapterIndex - 1]

    def size(self):
        return len(self.chapters)

    def addChapter(self, chapter):
        self.chapters.append(chapter)
        self.currentTimeMark = chapter.timeMark

    def addChapterFromFile(self, filename, tempo="1.0"):

        # Try to get the name of the chapter from the title
        # TODO: also support mp4 files via mp4v2
        name = ""
        if have_tagpy:
            try:
                name = tagpy.FileRef(filename).tag().title
                # Encode from unicode to utf-8 so it can be written to file
                name = name.encode("utf-8")
            except:
                print "tagpy: unable to get track title from: " + filename

        # If no track title found, use the filename
        if len(name) == 0:
            name = os.path.splitext(filename)[0]

        self.chapters.append(Chapter(self.currentTimeMark, name))

        try:
            # Update the cumalative time
            # These give different results!  Interesting...  Wonder which one is accurate?
            #  We'll probably need manual adjustment, so maybe it doesn't matter
            #self.currentTimeMark += lengthInSecondsMplayer(filename)
            #self.currentTimeMark += lengthInSecondsTagLib(filename)
            #self.currentTimeMark += lengthInSecondsFFplay(filename)
            self.currentTimeMark += lengthInSecondsSoxi(filename, tempo)
        except(LengthRetrievalError):
            print "Error reading file: " + filename
            sys.exit(1)

    def adjustChapterTimeMark(self, chapterIndex, adjustNumSeconds, cascade=False):
        """Easily adjust chapter markings, optionally adjusting each successive chapter
        adjustNumSeconds can be a fractional positive or negative
        """

        # For all of the chapters (+1 for the range function)
        for i in range(chapterIndex, len(self.chapters) + 1):
            self.getChapter(i).timeMark += adjustNumSeconds

            # Only do one chapter, or do all the rest?
            if not cascade:
                break

    def adjustTempo(self, tempo):
        """Adjust chapter offsets based on a new tempo"""
        for c in self.chapters:
            c.adjustTempo(tempo)

    def toString(self):
        """Get Whole chapter listing in mp4chap import/export format"""
        ret = ""
        for c in self.chapters:
            ret += c.toString() + "\n"
        return ret

    def toFile(self, filename):
        """Write out the chapters to a file"""
        fd = open(filename, 'w')
        fd.write(self.toString())
        fd.close()


def getCdTrackList(cd_device, track_count_offset):
    """Try to get a track listing from cddb.
    If none found, generate a generic track listing starting from track_count_offset
    """

    # Query the disc for disc info, and use the info to query FreeDB.org
    cd = DiscID.open(cd_device)
    disc_id = DiscID.disc_id(cd)
    num_tracks = disc_id[1]
    print "Num tracks: %d" % num_tracks
    lookup_successful = True
    try:
        (query_status, query_info) = CDDB.query(disc_id, client_name='audiobook_tool',
                client_version=1.0, host='localhost', user='audiobook_tool_user')
        if query_status == 211:
            print "Multiple discs found in CDDB:"
            for i in range(0, len(query_info)):
                print "%d: %s" % (i + 1, query_info[i]['title'])
            answer = askQuestion("Which select which disc? (blank for none) [1-%d]" % len(query_info))
            i = int(answer) - 1
            (cat, id) = [query_info[i]['category'], query_info[i]['disc_id']]
        elif query_status == 200:
            print "Found match in CDDB!"
            (cat,id) = [query_info['category'], query_info['disc_id']]
    except IOError:
        print "Warning: failed to connect internet database... using generic track names"
        lookup_successful = False
    except ValueError:
        print "Error: invalid cddb response, exiting..."
        sys.exit(1)

    # Populate a structure of lists to return to the user
    # (may be extended if more info is needed from the cddb lookup)
    track_list = []

    # If we found a match...
    if lookup_successful and query_status in [211, 200]:
        (read_status, read_info) = CDDB.read(cat, id, client_name='audiobook_tool', client_version=1.0,
                host='localhost', user='audiobook_tool_user')
        for i in range(0, num_tracks):
            title_key = "TTITLE%d" % i
            if read_info.has_key(title_key):
                track_list.append(read_info[title_key])
            else:
                print "Error: actual cd has %d tracks, but metadata from cddb has less than this" % num_tracks
                sys.exit(1)

    # We didn't find a match... generate the track listing manually
    else:
        for i in range(1, num_tracks + 1):
            track_list.append("Track %d" % (i + track_count_offset))

    return track_list


# Rip an audiobook consisting of multiple cds to wav files, one file per track on each disc

# Then, use the combine_and_encode to encode to a single audiobook

# Optionally use gen_chapter_list to generate chapter information for m4b files, injected with set_chapters

# This needs to be run in it's own temporary directory, otherwise it really clouds things up.

def interactivelyRipCds(output, cd_device, ignore_errors, disc_count, total_track_count):

    if not os.path.exists(output):
        os.mkdir(output)
    os.chdir(output)

    cdparanoia_options = ""
    if cd_device:
        cdparanoia_options += " -d " + shellQuote(cd_device)
    if ignore_errors:
        cdparanoia_options += " -Z "

    while True:
        askQuestion("Insert disc %d and press <ENTER> when ready" % disc_count)

        # Don't start until we know there's a disc in the drive
        poll_count = 0
        ret = 1
        while ret != 0:
            print "Looking for disc..."
            if poll_count > 30:
                print "Error: Could not find audio disc"
                sys.exit(1)
            ret = os.system("cdparanoia -Q %s 2>/dev/null" % cdparanoia_options)
            time.sleep(1)
            poll_count += 1

        # sleep for another 10 seconds to wait for auto insert access to calm down
        time.sleep(10)

        track_list = getCdTrackList(cd_device, total_track_count)
        total_track_count += len(track_list)
        track_count = 1

        for track_name in track_list:
            track_filename = '%.2d-%.2d-%s.wav' % (disc_count, track_count, track_name)
            print "Track filename: " + track_name

            rip_track = True
            # Default is to skip if the file exists
            if os.path.exists(track_filename) and not re.search("o", askQuestion("%s exists.  Skip or Overwrite? [So]" % track_filename), re.IGNORECASE):
                rip_track = False

            if rip_track:
                command_to_run = "cdparanoia %s --output-wav %d %s" % (cdparanoia_options, track_count, shellQuote(track_filename))
                runOrDie(command_to_run)

                # Testing
                #print "Running command: " + command_to_run
                #os.system("touch %s" % shellQuote(track_filename))

            track_count += 1

        runOrDie("eject %s" % (shellQuote(cd_device) if cd_device else ""))
        disc_count += 1

        if re.search("(n|no)", askQuestion("Continue with disk %d? [Yn]" % disc_count), re.IGNORECASE):
            break


# generate a chapter listing to stdout that can be imported via mp4chaps

# The idea is to get a generated listing, and then hack up the file,
# and then use mp4chaps to import to a file created with files_to_audiobooks

# Format: 00:00:00.000 Chapter 1
# TODO: break up chapter lists for resulting m4b files over the sample limit
def genChapterList(files, out_file="", tempo="1.0"):

    # sort the files, just in case
    files.sort()

    cl = ChapterList()

    for f in files:
        print "Adding file to chapter list: " + f
        cl.addChapterFromFile(f, tempo)

    if len(out_file) > 0:
        cl.toFile(out_file)

    return cl

def buildFilesString(files):
    ret = ""
    for f in files:
        ret += " %s" % shellQuote(f)
    return ret

def getRipCdOptions(args):
    cd_device = None
    ignore_errors = False
    opts, remaining_args = getopt.gnu_getopt(args, "", [ "cd_device=", "ignore_errors" ])
    for option, value in opts:
        if option == "--cd_device":
            cd_device = value
        elif option == "--ignore_errors":
            ignore_errors = True
    args = remaining_args
    return (cd_device, ignore_errors, args)

# Combines a bunch of audio files to a single mp3, m4b, or ogg audiobook
#  Supports any audio files supported by ffmpeg
#  Do this in one pass to avoid a path using intermediate files going to wav, raw, and then output
#  There is a lossy conversion, but for an audiobook, oh well...

# TODO: warn user if outputting to m4b file will have over
#  2 billion samples, or whatever the ipod limitation is... ugh
#  http://groups.google.com/group/macvisionaries/msg/f4acb49721b51834
#  could split files at known boundary to avoid the problem
#  2 bil / 22050 samples = 194783 seconds
#  = 54 hours.  Is that really our maximum?  Should be fine for most books... ?
#  -> roughly 775 m4b file is the maximum
#  Or is it 4 billion / 22050 = 108 hours?
#  -> 64:43 book had problems.  Chapters appeared fine, but iphone ipod app crashed
#     when it tried to play it (or scroll the chapters)

# TODO: incorporate gen_chapter_list for m4b files that must be broken up
def combineAndEncode(output, in_files, ffmpeg_input_options="", tempo="1.0"):

    for f in in_files:
        exitIfMissing(f)

    # Get output file extension
    output_extension = os.path.splitext(output)[1]

    if not ffmpeg_output_profiles.has_key(output_extension):
        print "Error: unknown resulting file format: " + output_extension
        sys.exit(1)

    # Pick ffmpeg output parameters based on output filetype
    output_codec = ffmpeg_output_profiles[output_extension]['codec']
    output_format = ffmpeg_output_profiles[output_extension]['format']

    error_filename = "/tmp/audiobook_tool_error.%s" % os.getpid()

    # Set up sox pipe for tempo option
    sox_pipe = ""
    if tempo != "1.0":
        # tempo segment of 30 (recommended for speech)
        sox_pipe = "| sox -L -t s16 -r %s -c %s - -L -t s16 -r %s -c %s - tempo %s 30" % (output_rate, output_channels, output_rate, output_channels, tempo)

    # Command to loop through all the input files and output to stdout
    #  Use the output rate and channels to cut down on conversions
    #  (note: a fifo was attempted, but the fifo would randomly close prematurely)
    #  Use a tmp file to carry the error code through the pipe
    intermediate_format_options = "-ar %s -ac %s -f s16le" % (output_rate, output_channels)
    # TODO: gather length by converting to a wav, getting the size via sox, piping with ffmpeg, and then cleaning up the wav file?
    #  that "could" be faster overall, even though it would slow down this step (writing each wav file to disc)
    player_command = "for i in %s ; do echo \"Encoding $i\" >&2; ffmpeg -v 0 -y %s /dev/stdout %s -i \"$i\" 2>/dev/null || { echo '' >&2; echo \"****** Failed to decode $i ******\" >&2 ; echo '' >&2 ; touch %s ; exit 1 ; } ; done""" % (buildFilesString(in_files), intermediate_format_options, ffmpeg_input_options, shellQuote(error_filename))

    # Now run the command to convert all data coming from stdin
    output_format_options = "-acodec %s -ar %s -ab %s -ac %s -f %s" % (output_codec, output_rate, output_bitrate, output_channels, output_format)
    runOrDie("rm -f %s ; ( %s ) %s | ffmpeg -v 0 -y %s -i /dev/stdin %s %s 2>/dev/null" % (shellQuote(error_filename), player_command, sox_pipe, intermediate_format_options, output_format_options, shellQuote(output)), error_message="Encoding failed")

    if os.path.exists(error_filename):
        print ""
        print "Failed to decode input files!"
        print ""
        print "Suggestion: specify ffmpeg input options with '--ffmpeg_input_format_options'"
        print ""
        print "  Note: these options will be applied to _all_ input files"
        print ""
        print "Suggestion 2: try manually converting that one file with another tool to a .wav file and use it to replace the broken input file"
        print ""
        print "  ie: mplayer <file unreadable by ffmpeg> -ao pcm:file=tmp.wav; ffmpeg -y -i tmp.wav -f wav out.wav"
        print ""
        print "  Doing the second conversion with ffmpeg probably won't make a difference except for the paranoid"
        print ""
        os.unlink(error_filename)
        sys.exit(1)

    print "Success!"

def playChapterSample(chapter_txt, audio_file, chapter_index, offset=0.0):
    """Easily play at a spot in a chapter to assist in verifying all chapter marks"""

    exitIfMissing(chapter_txt)
    exitIfMissing(audio_file)

    cl = ChapterList.fromFile(chapter_txt)
    chaps = []
    if not chapter_index:
        chaps.extend(range(1, cl.size() + 1))
    else:
        # turn "1,3-5,7,9-11" into [1, 3, 4, 5, 7, 9, 10, 11]
        for chap_range in chapter_index.split(','):
            chap_boundaries = chap_range.split('-')
            chaps.extend(range(int(chap_boundaries[0]), int(chap_boundaries[len(chap_boundaries) - 1]) + 1))
    for i in chaps:
        chapter = cl.getChapter(i)

        # is mplayer accurate when it comes to seeking? (ie: does it match seeking with chapters with Apple's software?)
        #  -> doing some rough checks, it appears to match quicktime on windows

        #  Documentation says it only seeks to second boundaries, but seeking to fractional seconds works
        print "Playing chapter %d (%s)" % (i, chapter.name)

        # Different methods to play the file
        # TODO: add back play duration support (I think only mplayer supports this)
        #  Idea being you can play each track for 1 second to easily scan them
        runOrDie("mplayer -ss %.3f %s >/dev/null 2>&1" % (chapter.timeMark + offset, shellQuote(audio_file)))

        #runOrDie("ffplay -ss %.3f %s 2>/dev/null" % (chapter.timeMark + offset, shellQuote(audio_file)))


def adjustChapter(chapter_txt, chapter_index, seconds, cascade):

    exitIfMissing(chapter_txt)

    cl = ChapterList.fromFile(chapter_txt)

    cl.adjustChapterTimeMark(chapter_index, seconds, cascade)

    cl.toFile(chapter_txt)

def setChapters(audio_file, chapter_txt):

    # mp4v2 seems to break when there are 2 chapters in a row with the same timestamp.
    #  this can be worked around by adding a millisecond difference
    #  A check should be added to make sure there are no chapters with duplicate timestamps
    #  -> but, the ipod freaks out from tiny chapters.  Just prepend the chapter with some
    #  text instead of adding an additional chapter.

    exitIfMissing(chapter_txt)
    exitIfMissing(audio_file)

    # Remove all chapters
    #  (fails if list doesn't exist... oh well)
    os.system("mp4chaps --remove %s" % shellQuote(audio_file))

    # Put correct chapter file in place if needs be, and clean up afterwards
    #  (TODO: if mp4v2 every gets python bindings, we won't have to do this kind of work around)
    tool_expected_chapter_file = output_extension = os.path.splitext(audio_file)[0] + ".chapters.txt"
    cleanup = False
    if tool_expected_chapter_file != chapter_txt:
        shutil.copyfile(chapter_txt, tool_expected_chapter_file)
        cleanup = True

    # Inject chapters
    runOrDie("mp4chaps --import %s" % shellQuote(audio_file))

    if cleanup:
        os.unlink(tool_expected_chapter_file)

def getChapters(audio_file, chapter_txt):

    exitIfMissing(audio_file)

    cl = ChapterList.fromM4bFile(audio_file)

    cl.toFile(chapter_txt)

def setMetaData(audio_file, author, title, trackTitle=""):

    exitIfMissing(audio_file)

    # Set track title to title if no track title was passed in
    if trackTitle == "":
        trackTitle = title

    # Set author and title (TODO: more info?)
    #  Use double quotes so apostraphes can be used in titles
    # Itunes audiobooks uses the album as the top level tree, and then the title in the subtree.
    #  TODO: maybe have optional title (song) for when books must be split into two
    runOrDie("mp4tags -i audiobook -artist %s -album %s -song %s %s" % (shellQuote(author), shellQuote(title), shellQuote(trackTitle), shellQuote(audio_file)))

def getMetaData(audio_file):
    exitIfMissing(audio_file)

    author = ""
    title = ""
    trackTitle = ""

    (status, output) = commands.getstatusoutput("mp4info %s" % shellQuote(audio_file))

    for line in output.split("\n"):
        title_ret = re.search(" Name: (.*)", line)
        author_ret = re.search(" (Artist|Author): (.*)", line)
        trackTitle_ret = re.search(" Album: (.*)", line)

        if title_ret:
            title = title_ret.group(1)
        elif author_ret:
            if not author and author_ret.group(2):
                author = author_ret.group(2)
        elif trackTitle_ret:
            trackTitle = trackTitle_ret.group(1)

    print "Author: " + author
    print "Title: " + title

    if author and title:
        return (author, title, trackTitle)
    else:
        print "Error getting metadata from: " + audio_file
        sys.exit(1)

def setCoverArt(audio_file, image_file):

    exitIfMissing(audio_file)
    exitIfMissing(image_file)

    # Set/Replace Coverart
    # (fails if no art is set... oh well)
    os.system("mp4art --remove %s" % shellQuote(audio_file))
    runOrDie("mp4art --add %s %s" % (shellQuote(image_file), shellQuote(audio_file)))

def getCoverArt(audio_file):

    exitIfMissing(audio_file)

    # Get Coverart
    os.system("mp4art --overwrite --force --extract %s" % shellQuote(audio_file))

    return glob.glob(os.path.splitext(audio_file)[0] + ".art*.jpg")

def optimizeMp4(audio_file):

    exitIfMissing(audio_file)

    # Optimize
    # -> optimizes mp4 file for http streaming
    runOrDie("mp4file --optimize %s" % (shellQuote(audio_file)))


def m4bFromFiles(audio_file, author, title, art_file, in_files, ffmpeg_input_format_options="", tempo="1.0"):
    """All-in-one method to generate a book once all the necessary information is given."""

    # Get the chapter name
    chapter_txt = os.path.splitext(audio_file)[0] + ".chapters.txt"

    cl = genChapterList(in_files, chapter_txt, tempo)

    # TODO: break up the chapter lists and combining/encoding if it exceeds the m4b max sample count

    combineAndEncode(audio_file, in_files, ffmpeg_input_format_options, tempo)

    setChapters(audio_file, chapter_txt)
    setMetaData(audio_file, author, title)
    setCoverArt(audio_file, art_file)
    optimizeMp4(audio_file)

    print "Success!"

def setM4bTempo(audio_file, in_file, ffmpeg_input_format_options="", tempo="1.0"):
    """Re-encode m4b file to another tempo (for devices that can't do it on the fly: android)
    Basically the same as combine_and_encode except it preserves metadata and adjusts chapters"""

    basename = os.path.splitext(audio_file)[0]

    # Get all the metadata
    cl = ChapterList.fromM4bFile(in_file)

    (author, title, trackTitle) = getMetaData(in_file)
    # Usually only one art file
    art_files = getCoverArt(in_file)

    # adjust the chapters and save out to file
    cl.adjustTempo(float(tempo))
    chapter_txt = basename + ".chapters.txt"
    cl.toFile(chapter_txt)

    # Re-encode
    combineAndEncode(audio_file, [in_file], ffmpeg_input_format_options, tempo)

    # Set the metadata
    setChapters(audio_file, chapter_txt)
    os.unlink(chapter_txt)
    setMetaData(audio_file, author, title, trackTitle)
    # Don't fail of no coverart found
    if len(art_files) > 0:
        setCoverArt(audio_file, art_files[0])
        os.unlink(art_files[0])
    optimizeMp4(audio_file)

    print "Success!"


def validateDependencies(progs):

    for p in progs:
        (status, output) = commands.getstatusoutput("which " + p)
        if len(output) == 0:
            print "Warning: %s not found" % p

def usage():
    usage_text="""
./audiobook_tool <sub command> <sub command arguments>

 Sub commands:

  rip_cds             <output dir> [--cd_device="device"] [ --ignore_errors ] [ <disc number> <num_previous_tracks> ]
  combine_and_encode  <AudioBook.[mp3|m4b|ogg]> <ffmpeg recognizable audio files> [--ffmpeg_input_format_options="options"] [--tempo <float ratio>]

  gen_chapter_list    <AudioBook.chapters.txt> <audio files> [--tempo <float ratio>]
  play_chapter        <AudioBook.chapters.txt> <AudioBook.m4b> [chapter range [offset]]  (range e.g. "7" or "1-3,6,8-10")
  adjust_chapter      <AudioBook.chapters.txt> <chapter index> [--cascade] <[-]seconds>

  set_chapters        <AudioBook.m4b> <AudioBook.chapters.txt>
  get_chapters        <AudioBook.m4b> <AudioBook.chapters.txt>
  set_metadata        <AudioBook.m4b> <Author> <Title> [Track Title]
  set_coverart        <AudioBook.m4b> <coverart image>
  optimize            <AudioBook.m4b>

  m4b_from_files      <AudioBook.m4b> <Author> <Title> <coverart image> <ffmpeg recognizable audio files> [--ffmpeg_input_format_options="options"] [--tempo <float ratio>]
  set_m4b_tempo       <AudioBook.m4b> <Original.m4b> [--ffmpeg_input_format_options="options"] <tempo float ratio>

"""
    print usage_text



if __name__ == "__main__":

    # Check for command line dependencies (only warn user)
    validateDependencies(cmd_line_dependencies.keys())

    try:
        subcommand = sys.argv[1]
        subcommand_args = sys.argv[2:]
    except:
        usage()
        sys.exit(1)

    # Parse and handle each of the sub-commands
    #  TODO: more elegant way to parse all of this?
    if 'rip_cds' == subcommand:
        (cd_device, ignore_errors, subcommand_args) = getRipCdOptions(subcommand_args)
        disc_num = "1"
        num_previous_tracks = "0"
        try:
            if len(subcommand_args) > 1:
                (output, disc_num, num_previous_tracks) = subcommand_args
            else:
                output = subcommand_args[0]
        except:
            usage()
            sys.exit(1)

        interactivelyRipCds(output, cd_device, ignore_errors, int(disc_num), int(num_previous_tracks))

    elif 'combine_and_encode' == subcommand:

        # Parse the options
        ffmpeg_input_format_options = ""
        tempo = "1.0"
        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "ffmpeg_input_format_options=", "tempo=" ])
        for option, value in opts:
            if option == "--ffmpeg_input_format_options":
                ffmpeg_input_format_options = value
            if option == "--tempo":
                tempo = value

        try:
            output = subcommand_args[0]
            in_files = subcommand_args[1:]

            if len(in_files) < 1:
                raise
        except:
            usage()
            sys.exit(1)

        combineAndEncode(output, in_files, ffmpeg_input_format_options, tempo)

    elif 'gen_chapter_list' == subcommand:
        # Parse the options
        tempo = "1.0"
        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "tempo=" ])
        for option, value in opts:
            if option == "--tempo":
                tempo = value

        try:
            out_file = subcommand_args[0]
            files = subcommand_args[1:]

            if len(files) < 1:
                raise

        except:
            usage()
            sys.exit(1)

        genChapterList(files, out_file, tempo)

    elif 'play_chapter' == subcommand:

        # Get optional offset
        offset = 0.0
        if len(subcommand_args) == 4:
            offset = float(subcommand_args[3])
            subcommand_args.pop()

        # Get optional chapter_index
        offset = 0.0
        if len(subcommand_args) == 3:
            chapter_index = subcommand_args[2]
            if not re.search("^\d+(?:-\d+)?(?:,\d+(?:-\d+)?)*$", chapter_index):
                usage()
                sys.exit(1)
            subcommand_args.pop()
        else:
            chapter_index = None

        try:
            (chapter_txt, audio_file) = subcommand_args
        except:
            usage()
            sys.exit(1)

        playChapterSample(chapter_txt, audio_file, chapter_index, offset)

    elif 'adjust_chapter' == subcommand:

        cascade = False
        for arg in subcommand_args:
            if arg == "--cascade":
                cascade = True
                subcommand_args.remove(arg)

        try:
            (chapter_txt, chapter_index, seconds) = subcommand_args
            chapter_index = int(chapter_index)
            seconds = float(seconds)
        except:
            usage()
            sys.exit(1)

        adjustChapter(chapter_txt, chapter_index, seconds, cascade)

    elif 'set_chapters' == subcommand:
        try:
            (audio_file, chapter_txt) = subcommand_args
        except:
            usage()
            sys.exit(1)

        setChapters(audio_file, chapter_txt)

    elif 'get_chapters' == subcommand:
        try:
            (audio_file, chapter_txt) = subcommand_args
        except:
            usage()
            sys.exit(1)

        getChapters(audio_file, chapter_txt)

    elif 'set_metadata' == subcommand:
        # Get optional offset
        trackTitle = ""
        if len(subcommand_args) == 4:
            trackTitle = subcommand_args[3]
            subcommand_args.pop()

        try:
            (audio_file, author, title) = subcommand_args
        except:
            usage()
            sys.exit(1)

        setMetaData(audio_file, author, title, trackTitle)

    elif 'set_coverart' == subcommand:
        try:
            (audio_file, image_file) = subcommand_args
        except:
            usage()
            sys.exit(1)

        setCoverArt(audio_file, image_file)

    elif 'optimize' == subcommand:
        try:
            (audio_file,) = subcommand_args
        except:
            usage()
            sys.exit(1)

        optimizeMp4(audio_file)

    elif 'm4b_from_files' == subcommand:

        # Parse the options
        ffmpeg_input_format_options = ""
        tempo = "1.0"
        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "ffmpeg_input_format_options=", "tempo=" ])
        for option, value in opts:
            if option == "--ffmpeg_input_format_options":
                ffmpeg_input_format_options = value
            if option == "--tempo":
                tempo = value

        try:
            audio_file = subcommand_args[0]
            author     = subcommand_args[1]
            title      = subcommand_args[2]
            art_file   = subcommand_args[3]
            in_files   = subcommand_args[4:]
        except:
            usage()
            sys.exit(1)

        m4bFromFiles(audio_file, author, title, art_file, in_files, ffmpeg_input_format_options, tempo)

    elif 'set_m4b_tempo' == subcommand:

        # Parse the options
        ffmpeg_input_format_options = ""
        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "ffmpeg_input_format_options=" ])
        for option, value in opts:
            if option == "--ffmpeg_input_format_options":
                ffmpeg_input_format_options = value

        try:
            (audio_file, in_file, tempo) = subcommand_args
        except:
            usage()
            sys.exit(1)

        setM4bTempo(audio_file, in_file, ffmpeg_input_format_options, tempo)

    else:
        usage()
        sys.exit(1)

    sys.exit(0)


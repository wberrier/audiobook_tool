#!/usr/bin/env python

# Author: Wade Berrier  <wberrier@gmail.com>

# License: GPLv2

# Collection of common functions and tasks when authoring audiobook files
# See the usage for more documentation

####################################################
# ffmpeg output settings for combine_and_encode
ffmpeg_program="ffmpeg"
output_bitrate="32000"
output_rate="22050"
output_channels="1"

ffmpeg_verbosity="-v warning"
# avconv's logging levels don't work, but ffmpeg's do.
# When the logging levels work, the null_pipe isn't needed and warnings
# are more apparent.
null_pipe="2>/dev/null"

# ffmpeg profiles
#  This program is focused on m4b,
#   but you can use it to encode to mp3/ogg and/or other ffmpeg codecs
# For ffmpeg aac notes: http://ffmpeg.org/trac/ffmpeg/wiki/AACEncodingGuide
# TODO: to support multiple versions of ffmpeg, we'd need to auto detect the aac codec name
# also, older versions don't support named logging levels (only numbers)
ffmpeg_output_profiles = {
        '.mp3': { 'codec': 'libmp3lame', 'format': 'mp3', 'options': '' },
        '.m4b': { 'codec': 'aac',        'format': 'mp4', 'options': '-strict experimental -cutoff 15000' },
        '.ogg': { 'codec': 'libvorbis',  'format': 'ogg', 'options': '' },
        }
#
####################################################

####################################################
# external programs this program depends on
cmd_line_dependencies = {
        ffmpeg_program: '',
        #'ffplay': '',
        'mplayer': '',
        'mp4chaps': '',
        'mp4art': '',
        'mp4tags': '',
        'mp4file': '',
        'mp4info': '',
        'soxi': '',
        'sox': '', # needed for tempo
        'cdparanoia': '',
        'eject': '',
        'wc': '', # needed to compute input length
        }
#
####################################################

import sys
import os
import readline
import re
import time
import shutil
import getopt
import glob
import commands

# for matroska tags
import xml.etree.ElementTree

try:
	import DiscID
	import CDDB
except:
	print("Warning: missing CDDB or DiscID support")

try:
    # Keep tagpy code around for reference, but don't require it
    import tagpy
    have_tagpy = True
except:
    have_tagpy = False

def shellQuote(str):
    return "'" + str.replace("'", "'\\''") + "'"

class LengthRetrievalError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class WavConversionError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class ChapterListFormatError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def lengthInSecondsFFmpeg(file, tempo="1.0"):
    """Decode input using ffmpeg to determine the length of the input

    Optionally takes a tempo arg, in which the file is first run through a sox pipe

    """

    wc_cmd = "wc --bytes"
    ffmpeg_decode_cmd = "%s %s -y -i %s -acodec pcm_s16le -f s16le -ar %s -ac %s - %s" % (ffmpeg_program, ffmpeg_verbosity, shellQuote(file), output_rate, output_channels, null_pipe)
    # Run through a sox pipe if we want to change the tempo
    #  Note: have sox write out to stdout, and count with wc.  Should be accurate, as ffmpeg is doing the decoding
    if tempo != "1.0":
        sox_cmd = "sox -L -t s2 -r %s -c %s - -t s2 -r %s -c %s - tempo %s 30" % (output_rate, output_channels, output_rate, output_channels, tempo)
        command = "%s | %s 2>/dev/null | %s" % (ffmpeg_decode_cmd, sox_cmd, wc_cmd)

    # Normal decode without the sox pipe
    else:
        command = "%s | %s" % (ffmpeg_decode_cmd, wc_cmd)

    status, output = commands.getstatusoutput(command)
    # If there was a return code error, or we counted 0 bytes -> error
    if status or output == "0":
        print output
        raise WavConversionError("Unable to convert file to .wav: " + file)

    # put this in a try block to help catch invalid output
    try:
        results = float(output)/(float(output_rate)*float(output_channels)*2.0) # 2 because 16 bits per sample, or 2 bytes per sample
    except:
        print "Command: " + command
        print "Output: " + output
        raise WavConversionError("Unable to convert file to .wav: " + file)
    return results

# Interesting bits:
#Sample Rate    : 22050
#Duration       : 00:04:51.92 = 6436800 samples ~ 21893.9 CDDA sectors
#soxi_duration_re = re.compile("Sample Rate\s+: (\d+).*Duration\s+: \d\d:\d\d:\d\d\.\d\d = (\d+) samples")
# Fine, break into two regexes, since I can't seem to match both in one pass (even with re.DOTALL)
soxi_sample_rate_re = re.compile("Sample Rate\s+: (\d+)")
soxi_duration_re = re.compile("Duration\s+: \d\d:\d\d:\d\d\.\d\d = (\d+) samples")
def lengthInSecondsSoxi(file, tempo="1.0"):
    """
    Use soxi to determine wave file lengths, and ffmpeg decoding for all others.

    Using ffmpeg to both convert to wav and to encode could also be contributing to the accuracy.  Different results
    are gotten when using mplayer to convert to a wav file (header info, or actual file output? Not sure...)
    """

    decodeRequired = False
    if os.path.splitext(file)[1] != ".wav" or tempo != "1.0":
        decodeRequired = True

    if decodeRequired:
        seconds = lengthInSecondsFFmpeg(file, tempo)
    else:
        status, output = commands.getstatusoutput("soxi %s" % shellQuote(file))

        try:
            (sample_rate,) = soxi_sample_rate_re.search(output).groups()
            (num_samples,) = soxi_duration_re.search(output).groups()
        except:
            raise LengthRetrievalError("Failed to parse: " + output)
        seconds = float(num_samples) / float(sample_rate)
        # TODO: check to see if "seconds = float(num_samples) / (float(sample_rate) * float(tempo))"
        #       would suffice instead of sending the wave file through sox when a tempo is given

    return float(seconds)

# TODO: method that manually parses wav header . we'd also have to know the specs from the wav header... ugh
#   but still, ffmpeg method only gives hundredths, where having thousandsth would help
#   (one hundred of a second rounding for a hundred chapters: could be 1 second off!)
# -> shelling out to soxi is probably sufficient

def runOrDie(command, error_message=""):
    print "Running: " + command
    ret = os.system(command)
    if ret:
        print command + " failed"
        if len(error_message):
            print "Error: " + error_message
        sys.exit(1)

def askQuestion(question):
    print question
    answer=raw_input()
    print "answer='%s'" % answer
    return answer

def exitIfMissing(filename):
    if not os.path.exists(filename):
        print "Error: file does not exist: " + filename
        sys.exit(1)

class Chapter:
    def __init__(self, index, timeMark, name):
        # Some chapter formats may depend on the index
        self.index = index
        self.timeMark = timeMark
        self.name = name

    def adjustTempo(self, tempo):
        """Compute new chapter mark based on new tempo"""
        self.timeMark /= float(tempo)

    def timeString(self):
        """This happens to match the format for both m4b and mka.  Can split out and duplicate if necessary"""

        total_seconds = int(self.timeMark)
        hours = total_seconds / 3600
        minutes = (total_seconds - (hours * 3600)) / 60
        seconds = (total_seconds - (hours * 3600) - (minutes * 60))

        # Round the decimal to 3 places (since that's all the chapter format accounts for)
        decimal = round(self.timeMark - total_seconds, 3)

        # Get the float to 3 places, and grab everything after the decimal
        milliseconds_string = ("%0.3f" % decimal).split('.')[1]

        return "%02d:%02d:%02d.%s" % (hours, minutes, seconds, milliseconds_string)


class M4bChapter(Chapter):
    def __init__(self, index, timeMark, name):
        Chapter.__init__(self, index, timeMark, name)

    def toString(self):
        return "%s %s" % (self.timeString(), self.name)


class MkaChapter(Chapter):
    def __init__(self, index, timeMark, name):
        Chapter.__init__(self, index, timeMark, name)

    def toString(self):
        # self.index is zero based, but matroska chapters are 1 based
        return "CHAPTER%02d=%s\nCHAPTER%02dNAME=%s" % (self.index + 1, self.timeString(), self.index + 1, self.name)


def totalSeconds(hours, minutes, seconds, decimal):

    total_seconds = 0.0
    total_seconds += float(hours) * float(3600) + float(minutes) * 60 + float(seconds) + float("0.%s" % decimal)

    return total_seconds




class ChapterList:
    def __init__(self):
        self.chapters = []
        self.currentTimeMark = 0.0

    def getChapter(self, chapterIndex):
        if not (chapterIndex > 0 and chapterIndex <= len(self.chapters)):
            print "Error: invalid chapter: %d" % chapterIndex
            sys.exit(1)

        return self.chapters[chapterIndex - 1]

    def size(self):
        return len(self.chapters)

    def addChapter(self, chapter):
        self.chapters.append(chapter)
        self.currentTimeMark = chapter.timeMark

    def addChapterFromFile(self, filename, tempo="1.0"):

        # Try to get the name of the chapter from the title
        # TODO: also support mp4 files via mp4v2
        name = ""
        if have_tagpy:
            try:
                name = tagpy.FileRef(filename).tag().title
                # Encode from unicode to utf-8 so it can be written to file
                name = name.encode("utf-8")
            except:
                print "tagpy: unable to get track title from: " + filename

        # If no track title found, use the filename
        if len(name) == 0:
            name = os.path.splitext(filename)[0]

        self.chapters.append(self.chapter_type(len(self.chapters), self.currentTimeMark, name))

        try:
            # Update the cumalative time
            self.currentTimeMark += lengthInSecondsSoxi(filename, tempo)
        except(LengthRetrievalError):
            print "Error reading file: " + filename
            sys.exit(1)

    def adjustChapterTimeMark(self, chapterIndex, adjustNumSeconds, cascade=False):
        """Easily adjust chapter markings, optionally adjusting each successive chapter
        adjustNumSeconds can be a fractional positive or negative
        """

        # For all of the chapters (+1 for the range function)
        for i in range(chapterIndex, len(self.chapters) + 1):
            self.getChapter(i).timeMark += adjustNumSeconds

            # Only do one chapter, or do all the rest?
            if not cascade:
                break

    def adjustTempo(self, tempo):
        """Adjust chapter offsets based on a new tempo"""
        for c in self.chapters:
            c.adjustTempo(tempo)

    def toString(self):
        """Get Whole chapter listing in the subclass import/export format"""
        ret = ""
        for c in self.chapters:
            ret += c.toString() + "\n"
        return ret

    def toFile(self, filename):
        """Write out the chapters to a file"""
        fd = open(filename, 'w')
        fd.write(self.toString())
        fd.close()

    def populateFromChapterFile(self, filename):

        # TODO: handle errors?
        output = open(filename).read()

        self.populateFromChapterOutput(output)

    def populateFromAudioFile(self, filename):
        pass


class M4bChapterList(ChapterList):
    def __init__(self):
        ChapterList.__init__(self)
        self.chapter_type = M4bChapter

    def populateFromChapterOutput(self, output):
        """Parse output to populate the chapter info"""

        chapter_line_re = re.compile("(\d\d):(\d\d):(\d\d).(\d\d\d) (.*)")

        count = 0
        for line in output.split('\n'):

            try:
                (hours, minutes, seconds, milliseconds, chapter_name) = chapter_line_re.search(line).groups()
            except AttributeError:
                error = "Error: unrecognizable chapter line: " + line
                print error
                raise ChapterListFormatError(error)

            total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

            self.addChapter(self.chapter_type(count, total_seconds, chapter_name))

            count = count + 1


    def populateFromAudioFile(self, filename):
        """ Specialied method """

        no_chapters_re = re.compile("File .* does not contain chapters of type QuickTime and Nero")

        # TODO: mp4chaps actually supports "--export" to do this thing
        (status, output) = commands.getstatusoutput("mp4chaps --list %s" % shellQuote(filename))

        # Check for empty chapter
        if no_chapters_re.search(output):
            return

        # This is the format given from mp4chap
        # Example: Chapter #030 - 19:00:40.111 - "Chapter 30"
        exported_chapter_line_re = re.compile("\tChapter #\d\d\d - (\d\d):(\d\d):(\d\d).(\d\d\d) - \"(.*)\"")

        # Skip first line
        count = -1
        for line in output.split("\n"):
            count += 1
            if count == 0:
                continue

            (hours, minutes, seconds, milliseconds, chapter_name) = exported_chapter_line_re.search(line).groups()
            total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

            self.addChapter(self.chapter_type(count, total_seconds, chapter_name))



class MkaChapterList(ChapterList):
    def __init__(self):
        ChapterList.__init__(self)
        self.chapter_type = MkaChapter

    def populateFromChapterOutput(self, output):
        """Parse filename to populate the chapter info"""

        # time or name
        line_type = "time"

        total_seconds = 0

        count = 1
        for line in output.split('\n'):

            index_str = "%02d" % count

            chapter_line_time_re = re.compile("CHAPTER%s=(\d\d):(\d\d):(\d\d).(\d\d\d)" % index_str)
            chapter_line_name_re = re.compile("CHAPTER%sNAME=(.*)" % index_str)

            if line_type == "time":

                try:
                    (hours, minutes, seconds, milliseconds) = chapter_line_time_re.search(line).groups()
                except AttributeError:
                    error = "Error: unrecognizable chapter line: " + line
                    print error
                    raise ChapterListFormatError(error)

                total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

                # get ready for next line
                line_type = "name"

            elif line_type == "name":

                try:
                    (chapter_name,) = chapter_line_name_re.search(line).groups()
                except AttributeError:
                    error = "Error: unrecognizable chapter line: " + line
                    print error
                    raise ChapterListFormatError(error)

                # The chapter file uses one based, the object is zero based
                self.addChapter(self.chapter_type(count-1, total_seconds, chapter_name))

                line_type = "time"

                count = count + 1


    def populateFromAudioFile(self, filename):
        """ Specialied method """

        no_chapters_re = re.compile("File .* does not contain chapters of type QuickTime and Nero")

        (status, output) = commands.getstatusoutput("mkvextract chapters %s -s" % shellQuote(filename))

        self.populateFromChapterOutput(output)


def AudioBookFactory(filename):
    """Get the appropriate book object for the format"""

    # Get format from filename
    filename_base, dot_extension = os.path.splitext(filename)
    if len(dot_extension) > 0 and dot_extension[0] == ".":
        book_format = dot_extension[1:]
    else:
        print "Unable to deduce chapter type from file: " + filename
        sys.exit(1)

    if book_format != "":
        if book_format == "m4b":
            return M4bAudioBook(filename)
        elif book_format == "mka":
            return MkaAudioBook(filename)
        else:
            print "Unsupported book type: " + book_format
            sys.exit(1)


def ChapterListFactory(chapter_format="", filename=""):
    """Get the appropriate chapter object for the format"""

    # Get format from filename
    if filename != "":
        # filename overrides the format
        filename, dot_extension = os.path.splitext(filename)
        if len(dot_extension) > 0 and dot_extension[0] == ".":
            chapter_format = dot_extension[1:]
        else:
            print "Unable to deduce chapter type from file: " + filename
            sys.exit(1)

    if chapter_format != "":
        if chapter_format == "m4b":
            return M4bChapterList()
        elif chapter_format == "mka":
            return MkaChapterList()
        else:
            print "Unsupported chapter type: " + chapter_format
            sys.exit(1)


def getCdTrackList(cd_device, track_count_offset):
    """Try to get a track listing from cddb.
    If none found, generate a generic track listing starting from track_count_offset
    """

    # Query the disc for disc info, and use the info to query FreeDB.org
    cd = DiscID.open(cd_device)
    disc_id = DiscID.disc_id(cd)
    num_tracks = disc_id[1]
    print "Num tracks: %d" % num_tracks
    lookup_successful = True
    try:
        (query_status, query_info) = CDDB.query(disc_id, client_name='audiobook_tool',
                client_version=1.0, host='localhost', user='audiobook_tool_user')
        if query_status == 211:
            print "Multiple discs found in CDDB:"
            for i in range(0, len(query_info)):
                print "%d: %s" % (i + 1, query_info[i]['title'])
            answer = askQuestion("Which select which disc? (blank for none) [1-%d]" % len(query_info))
            i = int(answer) - 1
            (cat, id) = [query_info[i]['category'], query_info[i]['disc_id']]
        elif query_status == 200:
            print "Found match in CDDB!"
            (cat,id) = [query_info['category'], query_info['disc_id']]
    except IOError:
        print "Warning: failed to connect internet database... using generic track names"
        lookup_successful = False
    except ValueError:
        print "Warning: invalid cddb response... using generic track names"
        lookup_successful = False

    # Populate a structure of lists to return to the user
    # (may be extended if more info is needed from the cddb lookup)
    track_list = []

    # If we found a match...
    if lookup_successful and query_status in [211, 200]:
        (read_status, read_info) = CDDB.read(cat, id, client_name='audiobook_tool', client_version=1.0,
                host='localhost', user='audiobook_tool_user')
        for i in range(0, num_tracks):
            title_key = "TTITLE%d" % i
            if read_info.has_key(title_key):
                track_list.append(read_info[title_key])
            else:
                print "Error: actual cd has %d tracks, but metadata from cddb has less than this" % num_tracks
                sys.exit(1)

    # We didn't find a match... generate the track listing manually
    else:
        for i in range(1, num_tracks + 1):
            track_list.append("Track %d" % (i + track_count_offset))

    return track_list


# Rip an audiobook consisting of multiple cds to wav files, one file per track on each disc

# Then, use the combine_and_encode to encode to a single audiobook

# Optionally use gen_chapter_list to generate chapter information for m4b files, injected with set_chapters

# This needs to be run in it's own temporary directory, otherwise it really clouds things up.

def interactivelyRipCds(output, cd_device, ignore_errors, disc_count, total_track_count):

    if not os.path.exists(output):
        os.mkdir(output)
    os.chdir(output)

    cdparanoia_options = ""
    if cd_device:
        cdparanoia_options += " -d " + shellQuote(cd_device)
    if ignore_errors:
        cdparanoia_options += " -Z "

    while True:
        askQuestion("Insert disc %d and press <ENTER> when ready" % disc_count)

        # Don't start until we know there's a disc in the drive
        poll_count = 0
        ret = 1
        while ret != 0:
            print "Looking for disc..."
            if poll_count > 30:
                print "Error: Could not find audio disc"
                sys.exit(1)
            ret = os.system("cdparanoia -Q %s 2>/dev/null" % cdparanoia_options)
            time.sleep(1)
            poll_count += 1

        # sleep for another 10 seconds to wait for auto insert access to calm down
        time.sleep(10)

        track_list = getCdTrackList(cd_device, total_track_count)
        total_track_count += len(track_list)
        track_count = 1

        for track_name in track_list:
            track_filename = '%.2d-%.2d-%s.wav' % (disc_count, track_count, track_name)
            print "Track filename: " + track_name

            rip_track = True
            # Default is to skip if the file exists
            if os.path.exists(track_filename) and not re.search("o", askQuestion("%s exists.  Skip or Overwrite? [So]" % track_filename), re.IGNORECASE):
                rip_track = False

            if rip_track:
                command_to_run = "cdparanoia %s --output-wav %d %s" % (cdparanoia_options, track_count, shellQuote(track_filename))
                runOrDie(command_to_run)

                # Testing
                #print "Running command: " + command_to_run
                #os.system("touch %s" % shellQuote(track_filename))

            track_count += 1

        runOrDie("eject %s" % (shellQuote(cd_device) if cd_device else ""))
        disc_count += 1

        if re.search("(n|no)", askQuestion("Continue with disk %d? [Yn]" % disc_count), re.IGNORECASE):
            break


# generate a chapter listing to stdout that can be imported via mp4chaps

# The idea is to get a generated listing, and then hack up the file,
# and then use mp4chaps to import to a file created with files_to_audiobooks

# Format: 00:00:00.000 Chapter 1
# TODO: break up chapter lists for resulting m4b files over the sample limit
def genChapterList(files, chapter_format, out_file="", tempo="1.0"):

    # sort the files, just in case
    files.sort()

    cl = ChapterListFactory(chapter_format=chapter_format)

    for f in files:
        print "Adding file to chapter list: " + f
        cl.addChapterFromFile(f, tempo)

    if len(out_file) > 0:
        cl.toFile(out_file)

    return cl

def buildFilesString(files):
    ret = ""
    for f in files:
        ret += " %s" % shellQuote(f)
    return ret

def getRipCdOptions(args):
    cd_device = None
    ignore_errors = False
    opts, remaining_args = getopt.gnu_getopt(args, "", [ "cd_device=", "ignore_errors" ])
    for option, value in opts:
        if option == "--cd_device":
            cd_device = value
        elif option == "--ignore_errors":
            ignore_errors = True
    args = remaining_args
    return (cd_device, ignore_errors, args)

# Combines a bunch of audio files to a single mp3, m4b, or ogg audiobook
#  Supports any audio files supported by ffmpeg
#  Do this in one pass to avoid a path using intermediate files going to wav, raw, and then output
#  There is a lossy conversion, but for an audiobook, oh well...

# TODO: warn user if outputting to m4b file will have over
#  2 billion samples, or whatever the ipod limitation is... ugh
#  http://groups.google.com/group/macvisionaries/msg/f4acb49721b51834
#  could split files at known boundary to avoid the problem
#  2 bil / 22050 samples = 194783 seconds
#  = 54 hours.  Is that really our maximum?  Should be fine for most books... ?
#  -> roughly 775 m4b file is the maximum
#  Or is it 4 billion / 22050 = 108 hours?
#  -> 64:43 book had problems.  Chapters appeared fine, but iphone ipod app crashed
#     when it tried to play it (or scroll the chapters)

# TODO: incorporate gen_chapter_list for m4b files that must be broken up
def combineAndEncode(output, in_files, ffmpeg_input_options="", tempo="1.0"):

    for f in in_files:
        exitIfMissing(f)

    # Get output file extension
    output_extension = os.path.splitext(output)[1]

    if not ffmpeg_output_profiles.has_key(output_extension):
        print "Error: '%s' is of unknown resulting file format: %s" % (output, output_extension)
        sys.exit(1)

    # Pick ffmpeg output parameters based on output filetype
    output_codec = ffmpeg_output_profiles[output_extension]['codec']
    codec_options = ffmpeg_output_profiles[output_extension]['options']
    output_format = ffmpeg_output_profiles[output_extension]['format']

    error_filename = "/tmp/audiobook_tool_error.%s" % os.getpid()

    # Set up sox pipe for tempo option
    sox_pipe = ""
    if tempo != "1.0":
        # tempo segment of 30 (recommended for speech)
        sox_pipe = "| sox -L -t s2 -r %s -c %s - -L -t s2 -r %s -c %s - tempo %s 30" % (output_rate, output_channels, output_rate, output_channels, tempo)

    # Command to loop through all the input files and output to stdout
    #  Use the output rate and channels to cut down on conversions
    #  (note: a fifo was attempted, but the fifo would randomly close prematurely)
    #  Use a tmp file to carry the error code through the pipe
    intermediate_format_options = "-ar %s -ac %s -f s16le" % (output_rate, output_channels)
    # TODO: gather length by converting to a wav, getting the size via sox, piping with ffmpeg, and then cleaning up the wav file?
    #  that "could" be faster overall, even though it would slow down this step (writing each wav file to disc)
    player_command = "for i in %s ; do echo \"Encoding $i\" >&2; %s %s -y -i \"$i\" %s %s - %s || { echo '' >&2; echo \"****** Failed to decode $i ******\" >&2 ; echo '' >&2 ; touch %s ; exit 1 ; } ; done""" % (buildFilesString(in_files), ffmpeg_program, ffmpeg_verbosity, ffmpeg_input_options, intermediate_format_options, null_pipe, shellQuote(error_filename))

    # Now run the command to convert all data coming from stdin
    output_format_options = "-acodec %s %s -ar %s -ab %s -ac %s -f %s" % (output_codec, codec_options, output_rate, output_bitrate, output_channels, output_format)
    runOrDie("rm -f %s ; ( %s ) %s | %s %s -y %s -i - %s %s %s" % (shellQuote(error_filename), player_command, sox_pipe, ffmpeg_program, ffmpeg_verbosity, intermediate_format_options, output_format_options, shellQuote(output), null_pipe), error_message="Encoding failed")

    if os.path.exists(error_filename):
        print ""
        print "Failed to decode input files!"
        print ""
        print "Suggestion: specify ffmpeg input options with '--ffmpeg_input_format_options'"
        print ""
        print "  Note: these options will be applied to _all_ input files"
        print ""
        print "Suggestion 2: try manually converting that one file with another tool to a .wav file and use it to replace the broken input file"
        print ""
        print "  ie: mplayer <file unreadable by ffmpeg> -ao pcm:file=tmp.wav; ffmpeg -y -i tmp.wav -f wav out.wav"
        print ""
        print "  Doing the second conversion with ffmpeg probably won't make a difference except for the paranoid"
        print ""
        print "Suggestion 3: Use mythffmpeg instead of ffmpeg by adjusting ffmpeg_program at the top of this file"
        print ""
        os.unlink(error_filename)
        sys.exit(1)

    print "Success!"

def playChapterSample(chapter_txt, audio_file, chapter_index, offset=0.0):
    """Easily play at a spot in a chapter to assist in verifying all chapter marks"""

    exitIfMissing(chapter_txt)
    exitIfMissing(audio_file)

    cl = ChapterListFactory(filename=audio_file)

    try:
        cl.populateFromChapterFile(chapter_txt)
    except:
        print "Error: unable to parse chapter list: " + chapter_txt
        sys.exit(1)

    chaps = []
    if not chapter_index:
        chaps.extend(range(1, cl.size() + 1))
    else:
        # turn "1,3-5,7,9-11" into [1, 3, 4, 5, 7, 9, 10, 11]
        for chap_range in chapter_index.split(','):
            chap_boundaries = chap_range.split('-')
            chaps.extend(range(int(chap_boundaries[0]), int(chap_boundaries[len(chap_boundaries) - 1]) + 1))
    for i in chaps:
        chapter = cl.getChapter(i)

        # is mplayer accurate when it comes to seeking? (ie: does it match seeking with chapters with Apple's software?)
        #  -> doing some rough checks, it appears to match quicktime on windows

        #  Documentation says it only seeks to second boundaries, but seeking to fractional seconds works
        print "Playing chapter %d (%s)" % (i, chapter.name)

        # Different methods to play the file
        # TODO: add back play duration support (I think only mplayer supports this)
        #  Idea being you can play each track for 1 second to easily scan them
        runOrDie("mplayer -ss %.3f %s >/dev/null 2>&1" % (chapter.timeMark + offset, shellQuote(audio_file)))

        #runOrDie("ffplay -ss %.3f %s 2>/dev/null" % (chapter.timeMark + offset, shellQuote(audio_file)))


def adjustChapter(chapter_format, chapter_txt, chapter_index, seconds, cascade):

    exitIfMissing(chapter_txt)

    cl = ChapterListFactory(chapter_format=chapter_format)

    cl.populateFromChapterFile(chapter_txt)

    cl.adjustChapterTimeMark(chapter_index, seconds, cascade)

    cl.toFile(chapter_txt)

def setChapterTempo(chapter_format, chapter_txt, tempo):

    exitIfMissing(chapter_txt)

    cl = ChapterListFactory(chapter_format=chapter_format)

    cl.populateFromChapterFile(chapter_txt)

    cl.adjustTempo(tempo)

    cl.toFile(chapter_txt)


class AudioBook:
    def __init__(self, audio_file):
        self.audio_file = audio_file

    def setChapters(self, chapter_txt):
        exitIfMissing(self.audio_file)
        exitIfMissing(chapter_txt)

    def getChapters(self):
        exitIfMissing(self.audio_file)

        cl = self.chapter_list_type()

        cl.populateFromAudioFile(self.audio_file)

        return cl

    def setMetaData(self):
        exitIfMissing(self.audio_file)

    def setCoverArt(self):
        exitIfMissing(self.audio_file)

    def optimize(self):
        exitIfMissing(self.audio_file)

    def fromFiles(self, author, title, art_file, in_files, ffmpeg_input_format_options="", tempo="1.0"):
        """All-in-one method to generate a book once all the necessary information is given."""

        # Get the chapter name
        chapter_txt = os.path.splitext(self.audio_file)[0] + ".chapters.txt"

        # Do this option first since it will catch the error of invalid resulting extension.
        # Otherwise, all the chapters are generated, which takes some time, only to fail on this step
        combineAndEncode(self.audio_file, in_files, ffmpeg_input_format_options, tempo)

        cl = genChapterList(in_files, self.chapter_format, chapter_txt, tempo)

        # TODO: break up the chapter lists and combining/encoding if it exceeds the m4b max sample count

        self.setChapters(chapter_txt)
        self.setMetaData(author, title)
        self.setCoverArt(art_file)
        self.optimize()

        print "Success!"

    def getMetaData(self):
        exitIfMissing(self.audio_file)

    def getCoverArt(self):
        exitIfMissing(self.audio_file)


class M4bAudioBook(AudioBook):
    def __init__(self, audio_file):
        AudioBook.__init__(self, audio_file)
        self.chapter_list_type = M4bChapterList
        self.chapter_format = "m4b"

    def setChapters(self, chapter_txt):

        AudioBook.setChapters(self, chapter_txt)

        # mp4v2 seems to break when there are 2 chapters in a row with the same timestamp.
        #  this can be worked around by adding a millisecond difference
        #  A check should be added to make sure there are no chapters with duplicate timestamps
        #  -> but, the ipod freaks out from tiny chapters.  Just prepend the chapter with some
        #  text instead of adding an additional chapter.

        # Remove all chapters
        #  (fails if list doesn't exist... oh well)
        os.system("mp4chaps --remove %s" % shellQuote(self.audio_file))

        # Put correct chapter file in place if needs be, and clean up afterwards
        #  (TODO: if mp4v2 every gets python bindings, we won't have to do this kind of work around)
        tool_expected_chapter_file = output_extension = os.path.splitext(self.audio_file)[0] + ".chapters.txt"
        cleanup = False
        if tool_expected_chapter_file != chapter_txt:
            shutil.copyfile(chapter_txt, tool_expected_chapter_file)
            cleanup = True

        # Inject chapters
        runOrDie("mp4chaps --import %s" % shellQuote(self.audio_file))

        if cleanup:
            os.unlink(tool_expected_chapter_file)

    def setMetaData(self, author, title, trackTitle=""):

        AudioBook.setMetaData(self)

        # Set track title to title if no track title was passed in
        if trackTitle == "":
            trackTitle = title

        # Set author and title (TODO: more info?)
        #  Use double quotes so apostraphes can be used in titles
        # Itunes audiobooks uses the album as the top level tree, and then the title in the subtree.
        #  TODO: maybe have optional title (song) for when books must be split into two
        runOrDie("mp4tags -i audiobook -artist %s -album %s -song %s %s" % (shellQuote(author), shellQuote(title), shellQuote(trackTitle), shellQuote(self.audio_file)))


    def setCoverArt(self, image_file):

        AudioBook.setCoverArt(self)

        exitIfMissing(image_file)

        # Set/Replace Coverart
        # (fails if no art is set... oh well)
        os.system("mp4art --remove %s" % shellQuote(self.audio_file))
        runOrDie("mp4art --add %s %s" % (shellQuote(image_file), shellQuote(self.audio_file)))

    def optimize(self):

        AudioBook.optimize(self)

        # Optimize
        # -> optimizes mp4 file for http streaming
        runOrDie("mp4file --optimize %s" % (shellQuote(self.audio_file)))

    def getMetaData(self):

        AudioBook.getMetaData(self)

        author = ""
        title = ""
        trackTitle = ""

        (status, output) = commands.getstatusoutput("mp4info %s" % shellQuote(self.audio_file))

        for line in output.split("\n"):
            title_ret = re.search(" Name: (.*)", line)
            author_ret = re.search(" (Artist|Author): (.*)", line)
            trackTitle_ret = re.search(" Album: (.*)", line)

            if title_ret:
                title = title_ret.group(1)
            elif author_ret:
                if not author and author_ret.group(2):
                    author = author_ret.group(2)
            elif trackTitle_ret:
                trackTitle = trackTitle_ret.group(1)

        print "Author: " + author
        print "Title: " + title

        if author and title:
            return (author, title, trackTitle)
        else:
            print "Error getting metadata from: " + self.audio_file
            sys.exit(1)

    def getCoverArt(self):

        AudioBook.getCoverArt(self)

        # Get Coverart
        os.system("mp4art --overwrite --force --extract %s" % shellQuote(self.audio_file))

        return glob.glob(os.path.splitext(self.audio_file)[0] + ".art*.jpg")



class MkaAudioBook(AudioBook):
    def __init__(self, audio_file):
        AudioBook.__init__(self, audio_file)
        self.chapter_list_type = MkaChapterList
        self.chapter_format = "mka"

    def setChapters(self, chapter_txt):

        AudioBook.setChapters(self, chapter_txt)

        # Inject chapters
        runOrDie("mkvpropedit %s --chapters %s" % (shellQuote(self.audio_file), shellQuote(chapter_txt)))

    def setMetaData(self, author, title, trackTitle=""):

        AudioBook.setMetaData(self)

        # Set track title to title if no track title was passed in
        if trackTitle == "":
            trackTitle = title

        # Set author and title (TODO: more info?)
        #  Use double quotes so apostraphes can be used in titles
        # TODO: no idea if this is valid for matroska
        # NOTE: trackTitle not used on mka

        # Seems artist can only be set this xml file
        # Ugly, but oh well
        tags_content = """
        <Tags>
          <Tag>
            <Targets>
              <TargetTypeValue>50</TargetTypeValue>
            </Targets>
            <Simple>
              <Name>ARTIST</Name>
              <String>%s</String>
            </Simple>
          </Tag>
        </Tags>
        """ % author

        xml_filename = self.audio_file + ".xml"

        fd = open(xml_filename, 'w')
        fd.write(tags_content)
        fd.close()

        runOrDie("mkvpropedit %s --edit info --set title=%s --tags track:a1:%s" % (shellQuote(self.audio_file), shellQuote(title), xml_filename))

        # Clean up
        os.unlink(xml_filename)

    def setCoverArt(self, image_file):

        AudioBook.setCoverArt(self)

        exitIfMissing(image_file)

        # Set/Replace Coverart
        os.system("mkvpropedit %s --delete-attachment 1" % (shellQuote(self.audio_file)))
        runOrDie("mkvpropedit %s --attachment-name cover --add-attachment %s" % (shellQuote(self.audio_file), shellQuote(image_file)))

    def optimize(self):

        AudioBook.optimize(self)

        print "optimize: unsupported for mka"

    def getMetaData(self):

        AudioBook.getMetaData(self)

        author = ""
        title = ""
        trackTitle = "" # TODO

        # First the info
        (status, output) = commands.getstatusoutput("mkvinfo %s" % shellQuote(self.audio_file))

        for line in output.split("\n"):
            title_ret = re.search("Title: (.*)", line)

            if title_ret:
                title = title_ret.group(1)
                trackTitle = title

        # Now for the tags
        (status, xml_output) = commands.getstatusoutput("mkvextract tags %s" % shellQuote(self.audio_file))

        try:
            # Get the artist
            root = xml.etree.ElementTree.fromstring(xml_output)
            # NOTE: these tags are case sensitive!
            for e in root.findall('.//Simple'):
                name = e.find('Name').text
                value = e.find('String').text
                if name.lower() == "artist":
                    author = value
        except:
            pass

        print "Author: " + author
        print "Title: " + title

        if author and title:
            return (author, title, trackTitle)
        else:
            print "Error getting metadata from: " + self.audio_file
            sys.exit(1)

    def getCoverArt(self):

        AudioBook.getCoverArt(self)

        # Get Coverart
        # NOTE: this just gets them from where we put them
        # We could go through all attachments looking for image mime-types
        os.system("mkvextract attachments %s 1:cover.jpg " % shellQuote(self.audio_file))

        if os.path.exists("cover.jpg"):
            return ["cover.jpg"]
        else:
            return [""]


def setTempo(audio_file, in_file, ffmpeg_input_format_options="", tempo="1.0"):
    """Re-encode file to another tempo (for devices that can't do it on the fly: android)
    Basically the same as combine_and_encode except it preserves metadata and adjusts chapters"""

    # Get all the metadata
    src_cl = ChapterListFactory(filename=in_file)
    src_cl.populateFromAudioFile(in_file)

    in_book = AudioBookFactory(in_file)
    (author, title, trackTitle) = in_book.getMetaData()
    # Usually only one art file
    art_files = in_book.getCoverArt()

    # adjust the chapters and save out to file
    src_cl.adjustTempo(float(tempo))

    # TODO: what if in/out are different types?  Need to convert chapter objects
    dest_cl = src_cl

    basename = os.path.splitext(audio_file)[0]
    chapter_txt = basename + ".chapters.txt"
    dest_cl.toFile(chapter_txt)

    # Re-encode
    combineAndEncode(audio_file, [in_file], ffmpeg_input_format_options, tempo)

    out_book = AudioBookFactory(audio_file)

    # Set the metadata
    out_book.setChapters(chapter_txt)
    os.unlink(chapter_txt)
    out_book.setMetaData(author, title, trackTitle)
    # Don't fail of no coverart found
    if len(art_files) > 0:
        out_book.setCoverArt(art_files[0])
        os.unlink(art_files[0])
    out_book.optimize()

    print "Success!"


def validateDependencies(progs):

    for p in progs:
        (status, output) = commands.getstatusoutput("which " + p)
        if status != 0:
            print "Warning: %s not found" % p

def usage():
    usage_text="""
./audiobook_tool <sub command> <sub command arguments>

 Sub commands:

  rip_cds             <output dir> [--cd_device="device"] [ --ignore_errors ] [ <disc number> <num_previous_tracks> ]
  combine_and_encode  <AudioBook.[mp3|m4b|ogg]> <ffmpeg recognizable audio files> [--ffmpeg_input_format_options="options"] [--tempo <float ratio>]

  gen_chapter_list    <AudioBook.chapters.txt> <audio files> [--tempo=<float ratio>] [--format=[m4b|mka]]
  play_chapter        <AudioBook.chapters.txt> <AudioBook.[m4b|mka]> [chapter range [offset]]  (range e.g. "7" or "1-3,6,8-10")
  adjust_chapter      <AudioBook.chapters.txt> <chapter index> [--format=[m4b|mka]] [--cascade] <[-]seconds>
  set_chapter_tempo   <AudioBook.chapters.txt> <float ratio> [--format=[m4b|mka]]

  set_chapters        <AudioBook.[m4b|mka]> <AudioBook.chapters.txt>
  get_chapters        <AudioBook.[m4b|mka]> <AudioBook.chapters.txt>
  set_metadata        <AudioBook.[m4b|mka]> <Author> <Title> [Track Title]
  set_coverart        <AudioBook.[m4b|mka]> <coverart image>
  optimize            <AudioBook.[m4b|mka]>

  book_from_files     <AudioBook.[m4b|mka]> <Author> <Title> <coverart image> <ffmpeg recognizable audio files> [--ffmpeg_input_format_options="options"] [--tempo=<float ratio>]
  set_book_tempo      <AudioBook.[m4b|mka]> <Original.[m4b|mka]> [--ffmpeg_input_format_options="options"] <tempo float ratio>

"""
    print usage_text



if __name__ == "__main__":

    # Check for command line dependencies (only warn user)
    validateDependencies(cmd_line_dependencies.keys())

    try:
        subcommand = sys.argv[1]
        subcommand_args = sys.argv[2:]
    except:
        usage()
        sys.exit(1)

    # Parse and handle each of the sub-commands
    #  TODO: more elegant way to parse all of this?
    if 'rip_cds' == subcommand:
        (cd_device, ignore_errors, subcommand_args) = getRipCdOptions(subcommand_args)
        disc_num = "1"
        num_previous_tracks = "0"
        try:
            if len(subcommand_args) > 1:
                (output, disc_num, num_previous_tracks) = subcommand_args
            else:
                output = subcommand_args[0]
        except:
            usage()
            sys.exit(1)

        interactivelyRipCds(output, cd_device, ignore_errors, int(disc_num), int(num_previous_tracks))

    elif 'combine_and_encode' == subcommand:

        # Parse the options
        ffmpeg_input_format_options = ""
        tempo = "1.0"
        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "ffmpeg_input_format_options=", "tempo=" ])
        for option, value in opts:
            if option == "--ffmpeg_input_format_options":
                ffmpeg_input_format_options = value
            if option == "--tempo":
                tempo = value

        try:
            output = subcommand_args[0]
            in_files = subcommand_args[1:]

            if len(in_files) < 1:
                raise
        except:
            usage()
            sys.exit(1)

        combineAndEncode(output, in_files, ffmpeg_input_format_options, tempo)

    elif 'gen_chapter_list' == subcommand:
        # Parse the options
        # Set some defaults
        tempo = "1.0"
        chapter_format = "m4b"
        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "tempo=", "format=" ])
        for option, value in opts:
            if option == "--tempo":
                tempo = value
            if option == "--format":
                chapter_format = value

        try:
            out_file = subcommand_args[0]
            files = subcommand_args[1:]

            if len(files) < 1:
                raise

        except:
            usage()
            sys.exit(1)

        genChapterList(files, chapter_format, out_file, tempo)

    elif 'play_chapter' == subcommand:

        # Get optional offset
        offset = 0.0
        if len(subcommand_args) == 4:
            offset = float(subcommand_args[3])
            subcommand_args.pop()

        # Get optional chapter_index
        offset = 0.0
        if len(subcommand_args) == 3:
            chapter_index = subcommand_args[2]
            if not re.search("^\d+(?:-\d+)?(?:,\d+(?:-\d+)?)*$", chapter_index):
                usage()
                sys.exit(1)
            subcommand_args.pop()
        else:
            chapter_index = None

        try:
            (chapter_txt, audio_file) = subcommand_args
        except:
            usage()
            sys.exit(1)

        playChapterSample(chapter_txt, audio_file, chapter_index, offset)

    elif 'adjust_chapter' == subcommand:

        cascade = False
        chapter_format = "m4b"

        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "cascade", "format=" ])
        for option, value in opts:
            if option == "--cascade":
                cascade = True
            if option == "--format":
                chapter_format = value

        try:
            (chapter_txt, chapter_index, seconds) = subcommand_args
            chapter_index = int(chapter_index)
            seconds = float(seconds)
        except:
            usage()
            sys.exit(1)

        adjustChapter(chapter_format, chapter_txt, chapter_index, seconds, cascade)

    elif 'set_chapter_tempo' == subcommand:

        chapter_format = "m4b"

        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "format=" ])
        for option, value in opts:
            if option == "--format":
                chapter_format = value

        try:
            (chapter_txt, tempo) = subcommand_args
            tempo = float(tempo)
        except:
            usage()
            sys.exit(1)

        setChapterTempo(chapter_format, chapter_txt, tempo)

    elif 'set_chapters' == subcommand:
        try:
            (audio_file, chapter_txt) = subcommand_args
        except:
            usage()
            sys.exit(1)

        book = AudioBookFactory(audio_file)

        book.setChapters(chapter_txt)

    elif 'get_chapters' == subcommand:
        try:
            (audio_file, chapter_txt) = subcommand_args
        except:
            usage()
            sys.exit(1)

        book = AudioBookFactory(audio_file)

        cl = book.getChapters()

        cl.toFile(chapter_txt)


    elif 'set_metadata' == subcommand:
        # Get optional offset
        trackTitle = ""
        if len(subcommand_args) == 4:
            trackTitle = subcommand_args[3]
            subcommand_args.pop()

        try:
            (audio_file, author, title) = subcommand_args
        except:
            usage()
            sys.exit(1)

        book = AudioBookFactory(audio_file)

        book.setMetaData(author, title, trackTitle)

    elif 'set_coverart' == subcommand:
        try:
            (audio_file, image_file) = subcommand_args
        except:
            usage()
            sys.exit(1)

        book = AudioBookFactory(audio_file)

        book.setCoverArt(image_file)

    elif 'optimize' == subcommand:
        try:
            (audio_file,) = subcommand_args
        except:
            usage()
            sys.exit(1)

        book = AudioBookFactory(audio_file)

        book.optimize()

    elif 'book_from_files' == subcommand:

        # Parse the options
        ffmpeg_input_format_options = ""
        tempo = "1.0"
        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "ffmpeg_input_format_options=", "tempo=" ])
        for option, value in opts:
            if option == "--ffmpeg_input_format_options":
                ffmpeg_input_format_options = value
            if option == "--tempo":
                tempo = value

        try:
            audio_file = subcommand_args[0]
            author     = subcommand_args[1]
            title      = subcommand_args[2]
            art_file   = subcommand_args[3]
            in_files   = subcommand_args[4:]
        except:
            usage()
            sys.exit(1)

        book = AudioBookFactory(audio_file)

        book.fromFiles(author, title, art_file, in_files, ffmpeg_input_format_options, tempo)

    elif 'set_book_tempo' == subcommand:

        # Parse the options
        ffmpeg_input_format_options = ""
        opts, subcommand_args = getopt.gnu_getopt(subcommand_args, "", [ "ffmpeg_input_format_options=" ])
        for option, value in opts:
            if option == "--ffmpeg_input_format_options":
                ffmpeg_input_format_options = value

        try:
            (audio_file, in_file, tempo) = subcommand_args
        except:
            usage()
            sys.exit(1)

        setTempo(audio_file, in_file, ffmpeg_input_format_options, tempo)

    else:
        usage()
        sys.exit(1)

    sys.exit(0)


#!/usr/bin/env python3

# Author: Wade Berrier  <wberrier@gmail.com>

# License: GPLv2

# Collection of common functions and tasks when authoring audiobook files
# See the usage for more documentation

import sys
import os
import re
import time
import shutil
import argparse
import glob
import subprocess
import base64

# for matroska tags
import xml.etree.ElementTree

try:
    # Keep tagpy code around for reference, but don't require it
    # TODO: is this redundant with mutagen?
    import tagpy
    have_tagpy = True
except Exception:
    have_tagpy = False

# TODO: what's the python convention for setting this
AUDIOBOOK_VERSION = "1.3"
AUDIOBOOK_CONTACT = "wberrier@gmail.com"

####################################################
# ffmpeg output settings for combine_and_encode
ffmpeg_program = "ffmpeg"
output_bitrate = "32000"
output_channels = "1"

ffmpeg_verbosity = "-v warning"
# avconv's logging levels don't work, but ffmpeg's do.
# When the logging levels work, the null_pipe isn't needed and warnings
# are more apparent.
null_pipe = "2>/dev/null"

# ffmpeg profiles
#  This program is focused on m4b,
#   but you can use it to encode to mp3/ogg and/or other ffmpeg codecs
# For ffmpeg aac notes: http://ffmpeg.org/trac/ffmpeg/wiki/AACEncodingGuide
# TODO: to support multiple versions of ffmpeg, we'd need to auto detect the aac codec name
# also, older versions don't support named logging levels (only numbers)
# NOTE: most profiles use 22050 since that's mono cd quality
ffmpeg_output_profiles = {
    '.mp3':  {'codec': 'libmp3lame', 'format': 'mp3',      'sample_rate': '22050', 'options': ''},
    '.m4b':  {'codec': 'aac',        'format': 'mp4',      'sample_rate': '22050', 'options': '-strict experimental -cutoff 15000'},
    '.ogg':  {'codec': 'libvorbis',  'format': 'ogg',      'sample_rate': '22050', 'options': ''},
    '.opus': {'codec': 'libopus',    'format': 'opus',     'sample_rate': '24000', 'options': ''},
    '.mka':  {'codec': 'libopus',    'format': 'matroska', 'sample_rate': '24000', 'options': '-dash 1'},
    # webm requires 24000 sample rate, and it looks like ffmpeg is requiring that of libopus in matroska format
    '.webm': {'codec': 'libopus',    'format': 'webm',     'sample_rate': '24000', 'options': '-dash 1'},
}
#
####################################################

audio_extensions = ['m4b', 'mka', 'opus', 'webm', 'ogg', 'mp3']
book_extensions = ['m4b', 'mka', 'opus', 'webm', 'ogg']

####################################################
# external programs this program depends on
cmd_line_dependencies = {
    ffmpeg_program: '',
    # 'ffplay': '',
    'mplayer': '',
    'mp4chaps': '',
    'mp4art': '',
    'mp4tags': '',
    'mp4file': '',
    'mp4info': '',
    'soxi': '',
    'sox': '',  # needed for tempo
    'cdparanoia': '',
    'icedax': '',
    'cd-discid': '',  # needed for the icedax ripper
    'eject': '',
    'wc': '',  # needed to compute input length
    'mkvpropedit': '',
    'mkvmerge': '',
    'mkvextract': '',
    'mkvinfo': '',
}
#
####################################################


def shellQuote(str):
    """TODO: use shlex?"""
    return "'" + str.replace("'", "'\\''") + "'"


class LengthRetrievalError(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class WavConversionError(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class ChapterListFormatError(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


def lengthInSecondsFFmpeg(file,  ffmpeg_output_profile, tempo=1.0):
    """Decode input using ffmpeg to determine the length of the input

    Optionally takes a tempo arg, in which the file is first run through a sox pipe

    """

    output_rate = ffmpeg_output_profile['sample_rate']

    wc_cmd = "wc --bytes"
    ffmpeg_decode_cmd = "%s %s -y -i %s -acodec pcm_s16le -f s16le -ar %s -ac %s - %s" % (ffmpeg_program, ffmpeg_verbosity, shellQuote(file), output_rate, output_channels, null_pipe)
    # Run through a sox pipe if we want to change the tempo
    #  Note: have sox write out to stdout, and count with wc.  Should be accurate, as ffmpeg is doing the decoding
    if tempo != 1.0:
        sox_cmd = "sox -L -t s2 -r %s -c %s - -t s2 -r %s -c %s - tempo %s 30" % (output_rate, output_channels, output_rate, output_channels, tempo)
        command = "%s | %s 2>/dev/null | %s" % (ffmpeg_decode_cmd, sox_cmd, wc_cmd)

    # Normal decode without the sox pipe
    else:
        command = "%s | %s" % (ffmpeg_decode_cmd, wc_cmd)

    status, output = subprocess.getstatusoutput(command)
    # If there was a return code error, or we counted 0 bytes -> error
    if status or output == "0":
        print(output)
        raise WavConversionError("Unable to convert file to .wav: " + file)

    # put this in a try block to help catch invalid output
    try:
        results = float(output)/(float(output_rate)*float(output_channels)*2.0)  # 2 because 16 bits per sample, or 2 bytes per sample
    except Exception:
        print("Command: " + command)
        print("Output: " + output)
        raise WavConversionError("Unable to convert file to .wav: " + file)
    return results


# Interesting bits:
# Sample Rate    : 22050
# Duration       : 00:04:51.92 = 6436800 samples ~ 21893.9 CDDA sectors
# soxi_duration_re = re.compile("Sample Rate\s+: (\d+).*Duration\s+: \d\d:\d\d:\d\d\.\d\d = (\d+) samples")
# Fine, break into two regexes, since I can't seem to match both in one pass (even with re.DOTALL)
soxi_sample_rate_re = re.compile(r"Sample Rate\s+: (\d+)")
soxi_duration_re = re.compile(r"Duration\s+: \d\d:\d\d:\d\d\.\d\d = (\d+) samples")


def lengthInSecondsSoxi(file, ffmpeg_output_profile, tempo=1.0):
    """
    Use soxi to determine wave file lengths, and ffmpeg decoding for all others.

    Using ffmpeg to both convert to wav and to encode could also be contributing to the accuracy.  Different results
    are gotten when using mplayer to convert to a wav file (header info, or actual file output? Not sure...)
    """

    decodeRequired = False
    if os.path.splitext(file)[1] != ".wav" or tempo != 1.0:
        decodeRequired = True

    if decodeRequired:
        seconds = lengthInSecondsFFmpeg(file, ffmpeg_output_profile, tempo)
    else:
        status, output = subprocess.getstatusoutput("soxi %s" % shellQuote(file))

        try:
            (sample_rate,) = soxi_sample_rate_re.search(output).groups()
            (num_samples,) = soxi_duration_re.search(output).groups()
        except Exception:
            raise LengthRetrievalError("Failed to parse: " + output)
        seconds = float(num_samples) / float(sample_rate)
        # TODO: check to see if "seconds = float(num_samples) / (float(sample_rate) * float(tempo))"
        #       would suffice instead of sending the wave file through sox when a tempo is given

    return float(seconds)

# TODO: method that manually parses wav header . we'd also have to know the specs from the wav header... ugh
#   but still, ffmpeg method only gives hundredths, where having thousandsth would help
#   (one hundred of a second rounding for a hundred chapters: could be 1 second off!)
# -> shelling out to soxi is probably sufficient


def runOrDie(command, error_message=""):
    print("Running: " + command)
    ret = os.system(command)
    if ret:
        print(command + " failed")
        if len(error_message):
            print("Error: " + error_message)
        sys.exit(1)


def askQuestion(question):
    print(question)
    answer = input()
    print("answer='%s'" % answer)
    return answer


def exitIfMissing(filename):
    if not os.path.exists(filename):
        print("Error: file does not exist: " + filename)
        sys.exit(1)


class Chapter:
    def __init__(self, index, timeMark, name):
        # Some chapter formats may depend on the index
        self.index = index
        self.timeMark = timeMark
        self.name = name

    def adjustTempo(self, tempo):
        """Compute new chapter mark based on new tempo"""
        self.timeMark /= tempo

    def timeString(self):
        """This happens to match the format for both m4b and mka.  Can split out and duplicate if necessary"""

        total_seconds = int(self.timeMark)
        hours = total_seconds // 3600
        minutes = (total_seconds - (hours * 3600)) // 60
        seconds = (total_seconds - (hours * 3600) - (minutes * 60))

        # Round the decimal to 3 places (since that's all the chapter format accounts for)
        decimal = round(self.timeMark - total_seconds, 3)

        # Get the float to 3 places, and grab everything after the decimal
        milliseconds_string = ("%0.3f" % decimal).split('.')[1]

        return "%02d:%02d:%02d.%s" % (hours, minutes, seconds, milliseconds_string)


class M4bChapter(Chapter):
    def __init__(self, index, timeMark, name):
        Chapter.__init__(self, index, timeMark, name)

    def toString(self):
        return "%s %s" % (self.timeString(), self.name)


class CommentFormatChapter(Chapter):
    """This chapter type is shared amongs several containers.  Abstract out to be shared"""

    def __init__(self, index, timeMark, name):
        Chapter.__init__(self, index, timeMark, name)

    def toString(self):
        # self.index is zero based, but matroska chapters are 1 based
        return "CHAPTER%03d=%s\nCHAPTER%03dNAME=%s" % (self.index + 1, self.timeString(), self.index + 1, self.name)


def totalSeconds(hours, minutes, seconds, decimal):

    total_seconds = 0.0
    total_seconds += float(hours) * float(3600) + float(minutes) * 60 + float(seconds) + float("0.%s" % decimal)

    return total_seconds


class ChapterList:
    def __init__(self):
        self.chapters = []
        self.currentTimeMark = 0.0

    def getChapter(self, chapterIndex):
        if not (chapterIndex > 0 and chapterIndex <= len(self.chapters)):
            print("Error: invalid chapter: %d" % chapterIndex)
            sys.exit(1)

        return self.chapters[chapterIndex - 1]

    def size(self):
        return len(self.chapters)

    def addChapter(self, chapter):

        # Make sure the correct type of chapter is being constructed
        # (useful for conversions)
        # gotta be a smoother way to do this...
        self.chapters.append(self.chapter_type(chapter.index, chapter.timeMark, chapter.name))
        self.currentTimeMark = chapter.timeMark

    def addChapterFromFile(self, filename, tempo=1.0):

        # Try to get the name of the chapter from the title
        # TODO: also support mp4 files via mp4v2
        name = ""
        if have_tagpy:
            try:
                name = tagpy.FileRef(filename).tag().title
                # Encode from unicode to utf-8 so it can be written to file
                name = name.encode("utf-8")
            except Exception:
                print("tagpy: unable to get track title from: " + filename)

        # If no track title found, use the filename
        if len(name) == 0:
            name = os.path.splitext(filename)[0]

        self.chapters.append(self.chapter_type(len(self.chapters), self.currentTimeMark, name))

        try:
            # Update the cumalative time
            self.currentTimeMark += lengthInSecondsSoxi(filename, ffmpeg_output_profiles[self.chapter_format], tempo)
        except(LengthRetrievalError):
            print("Error reading file: " + filename)
            sys.exit(1)

    def adjustChapterTimeMark(self, chapterIndex, adjustNumSeconds, cascade=False):
        """Easily adjust chapter markings, optionally adjusting each successive chapter
        adjustNumSeconds can be a fractional positive or negative
        """

        # For all of the chapters (+1 for the range function)
        for i in range(chapterIndex, len(self.chapters) + 1):
            self.getChapter(i).timeMark += adjustNumSeconds

            # Only do one chapter, or do all the rest?
            if not cascade:
                break

    def adjustTempo(self, tempo):
        """Adjust chapter offsets based on a new tempo"""
        for c in self.chapters:
            c.adjustTempo(tempo)

    def resetIndicies(self):
        """Mostly internal housekeeping method"""

        # Reset chapter indexes (which internally are zero based)
        count = 0
        for chap in self.chapters:
            chap.index = count
            count = count + 1

    def removeChapter(self, index):
        """Remove a chapter.

        This is trivial for m4b, but provide this for comment chapters, which is a pain to do by hand."""

        internal_index = index - 1

        # Chapters indicies are 1 based, this list is zero based
        if internal_index < len(self.chapters):
            self.chapters.pop(internal_index)
        else:
            print("Chapter list does not contain index: {}".format(index))
            sys.exit(1)

        # Since chapter was removed, reset these indicies (ugh)
        self.resetIndicies()

    def toString(self):
        """Get Whole chapter listing in the subclass import/export format"""
        ret = ""
        for c in self.chapters:
            ret += c.toString() + "\n"
        return ret

    def toFile(self, filename):
        """Write out the chapters to a file"""
        fd = open(filename, 'w')
        fd.write(self.toString())
        fd.close()

    def populateFromChapterFile(self, filename):

        # TODO: handle errors?
        output = open(filename).read()

        self.populateFromChapterOutput(output)

    def populateFromAudioFile(self, filename):
        pass


class M4bChapterList(ChapterList):
    def __init__(self):
        ChapterList.__init__(self)
        self.chapter_type = M4bChapter
        self.chapter_format = ".m4b"

    def populateFromChapterOutput(self, output):
        """Parse output to populate the chapter info"""

        chapter_line_re = re.compile(r"(\d\d):(\d\d):(\d\d).(\d\d\d) (.*)")

        count = 0
        for line in output.split('\n'):

            # skip whitespace only lines (some editors love to put blank lines at the end of files)
            matches = re.search(r"^\s*$", line)
            if matches:
                continue

            try:
                (hours, minutes, seconds, milliseconds, chapter_name) = chapter_line_re.search(line).groups()
            except AttributeError:
                error = "Error: unrecognizable chapter line: " + line
                print(error)
                raise ChapterListFormatError(error)

            total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

            self.addChapter(self.chapter_type(count, total_seconds, chapter_name))

            count = count + 1

    def populateFromAudioFile(self, filename):
        """ Specialied method """

        no_chapters_re = re.compile(r"File .* does not contain chapters of type QuickTime and Nero")

        # TODO: mp4chaps actually supports "--export" to do this thing
        (status, output) = subprocess.getstatusoutput("mp4chaps --list %s" % shellQuote(filename))

        # Check for empty chapter
        if no_chapters_re.search(output):
            return

        # This is the format given from mp4chap
        # Example: Chapter #030 - 19:00:40.111 - "Chapter 30"
        exported_chapter_line_re = re.compile(r"\tChapter #\d\d\d - (\d\d):(\d\d):(\d\d).(\d\d\d) - \"(.*)\"")

        # Skip first line
        count = -1
        for line in output.split("\n"):
            count += 1
            if count == 0:
                continue

            (hours, minutes, seconds, milliseconds, chapter_name) = exported_chapter_line_re.search(line).groups()
            total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

            self.addChapter(self.chapter_type(count, total_seconds, chapter_name))


class CommentFormatChapterList(ChapterList):
    def __init__(self):
        ChapterList.__init__(self)

    @staticmethod
    def _validateIndex(index_str, index, line):
        """Make sure it's the index we're expecting"""

        # Remove leading zeros
        while len(index_str) > 0 and index_str[0] == '0':
            index_str = index_str[1:]

        if int(index_str) != index:
            error = "Error: unexpected chapter index from line: " + line
            print(error)
            raise ChapterListFormatError(error)

    def populateFromChapterOutput(self, output):
        """Parse filename to populate the chapter info"""

        # time or name
        line_type = "time"

        total_seconds = 0

        count = 1
        for line in output.split('\n'):

            if line == "":
                continue

            chapter_line_time_re = re.compile(r"CHAPTER(\d+)=(\d\d):(\d\d):(\d\d).(\d\d\d)")
            chapter_line_name_re = re.compile(r"CHAPTER(\d+)NAME=(.*)")

            if line_type == "time":

                try:
                    (index_str, hours, minutes, seconds, milliseconds) = chapter_line_time_re.search(line).groups()
                except AttributeError:
                    error = "Error: unrecognizable chapter line: " + line
                    print(error)
                    raise ChapterListFormatError(error)

                self._validateIndex(index_str, count, line)

                total_seconds = totalSeconds(hours, minutes, seconds, milliseconds)

                # get ready for next line
                line_type = "name"

            elif line_type == "name":

                try:
                    (index_str, chapter_name,) = chapter_line_name_re.search(line).groups()
                except AttributeError:
                    error = "Error: unrecognizable chapter line: " + line
                    print(error)
                    raise ChapterListFormatError(error)

                self._validateIndex(index_str, count, line)

                # The chapter file uses one based, the object is zero based
                self.addChapter(self.chapter_type(count-1, total_seconds, chapter_name))

                line_type = "time"

                count = count + 1


class MkaChapterList(CommentFormatChapterList):
    def __init__(self):
        CommentFormatChapterList.__init__(self)
        self.chapter_type = CommentFormatChapter
        self.chapter_format = ".mka"

    def populateFromAudioFile(self, filename):
        """ Specialied method """

        (status, output) = subprocess.getstatusoutput("mkvextract chapters %s -s" % shellQuote(filename))

        self.populateFromChapterOutput(output)


class MutagenChapterList(CommentFormatChapterList):
    def __init__(self):
        CommentFormatChapterList.__init__(self)
        self.chapter_type = CommentFormatChapter

    def populateFromAudioFile(self, filename):
        """ Specialied method """

        mutagen_file = self.mutagen_type(filename)

        chapter_output = ""

        chapter_count = 1

        while True:
            chapter_time_tag = "CHAPTER%03d" % chapter_count
            chapter_name_tag = "CHAPTER%03dNAME" % chapter_count

            if chapter_time_tag in mutagen_file and chapter_name_tag in mutagen_file:
                # print "Found chapter tags for: %d" % chapter_count
                chapter_output += chapter_time_tag + '=' + mutagen_file[chapter_time_tag][0] + '\n'
                chapter_output += chapter_name_tag + '=' + mutagen_file[chapter_name_tag][0] + '\n'
            else:
                break

            chapter_count = chapter_count + 1

        self.populateFromChapterOutput(chapter_output)


class OggChapterList(MutagenChapterList):
    def __init__(self):
        MutagenChapterList.__init__(self)
        self.chapter_format = ".ogg"

        # TODO: where to do imports, in case mutagen isn't installed?
        import mutagen.oggvorbis

        self.mutagen_type = mutagen.oggvorbis.OggVorbis


class OpusChapterList(MutagenChapterList):
    def __init__(self):
        MutagenChapterList.__init__(self)
        self.chapter_format = ".opus"

        # TODO: where to do imports, in case mutagen isn't installed?
        import mutagen.oggopus

        self.mutagen_type = mutagen.oggopus.OggOpus


class MP3ChapterList:
    def __init__(self):
        """TODO"""
        pass

    def populateFromAudioFile(self, filename):
        print("Warning: mp3 chapters not supported: chapters not loaded")

    def toFile(self, filename):
        print("Warning: mp3 chapters not supported: chapters not saved")
        open(filename, 'w').write("")


def AudioBookFactory(filename):
    """Get the appropriate book object for the format"""

    # Get format from filename
    filename_base, dot_extension = os.path.splitext(filename)
    if len(dot_extension) > 0 and dot_extension[0] == ".":
        book_format = dot_extension[1:]
    else:
        print("Unable to deduce chapter type from file: " + filename)
        sys.exit(1)

    if book_format != "":
        if book_format == "m4b":
            return M4bAudioBook(filename)
        elif book_format == "mka" or book_format == "webm":
            return MkaAudioBook(filename)
        elif book_format == "ogg":
            return OggAudioBook(filename)
        elif book_format == "opus":
            return OpusAudioBook(filename)
        elif book_format == "mp3":
            return MP3AudioBook(filename)
        else:
            print("Unsupported book type: " + book_format)
            sys.exit(1)


def ChapterListFactory(chapter_format="", filename=""):
    """Get the appropriate chapter object for the format"""

    # Get format from filename
    if filename != "":
        # filename overrides the format
        filename, dot_extension = os.path.splitext(filename)
        if len(dot_extension) > 0 and dot_extension[0] == ".":
            chapter_format = dot_extension[1:]
        else:
            print("Unable to deduce chapter type from file: " + filename)
            sys.exit(1)

    if chapter_format != "":
        if chapter_format == "m4b":
            return M4bChapterList()
        elif chapter_format == "mka" or chapter_format == "webm":
            return MkaChapterList()
        elif chapter_format == "ogg":
            return OggChapterList()
        elif chapter_format == "opus":
            return OpusChapterList()
        elif chapter_format == "mp3":
            return MP3ChapterList()
        else:
            print("Unsupported chapter type: " + chapter_format)
            sys.exit(1)


def getCdInfo(cd_device):
    """Get discid and number of tracks"""

    try:
        import libdiscid
        disc = libdiscid.read(device=cd_device)
        disc_id = disc.id
        num_tracks = disc.last_track - disc.first_track + 1
        return disc_id, num_tracks
    except ImportError:
        print("libdiscid module not found")
        sys.exit(1)
    except Exception:
        print("Unable to read disc id")
        sys.exit(1)


# TODO: have a track name metadata interface, and support multiple backends?

class MusicBrainzMetadata:
    """Helper to query from structure"""

    def __init__(self, info):
        self.info = info

    # TODO: use properties for these?

    def get_album_title(self):

        result = ''

        result += self.info['artist-credit-phrase']

        result += ' - ' + self.info['title']

        # TODO: safe to assume these indicies?
        result += ' (' + self.info['release-event-list'][0]['area']['iso-3166-1-code-list'][0] + ')'

        return result

    def get_track_titles(self):
        results = []

        # TODO: safe to assume these indicies?
        for track in self.info['medium-list'][0]['track-list']:
            results.append(track['recording']['title'])

        return results


def getCdMetaData(disc_id):
    """Get metadata from musicbrainz if the module is available"""

    metadata = None

    try:
        import musicbrainzngs
        musicbrainzngs.set_useragent('audiobook_tool', AUDIOBOOK_VERSION, AUDIOBOOK_CONTACT)

        releases = musicbrainzngs.get_releases_by_discid(
            disc_id, includes=["artists", "recordings"])

        num_releases = len(releases['disc']['release-list'])

        selection_index = None

        if num_releases > 1:
            print("Multiple discs found:")

            for index, release in enumerate(releases['disc']['release-list']):
                metadata_attempt = MusicBrainzMetadata(release)
                print("%d: %s" % (index + 1, metadata_attempt.get_album_title()))

            answer = askQuestion("Which select which disc? (blank for none) [1-%d]" % num_releases)
            if answer != '':
                selection_index = int(answer) - 1
        elif num_releases == 1:
            selection_index = 0

        # NOTE: can't check for True, since zero is valid (but False)
        if selection_index is not None:
            metadata = MusicBrainzMetadata(releases['disc']['release-list'][selection_index])

    except ImportError:
        print("Warning: missing musicbrainzngs module...")
    except musicbrainzngs.MusicBrainzError:
        print("Warning: failed to retrieve metadata from database...")
    except KeyError:
        print("Warning: unable to parse metadata...")
    except IndexError:
        print("Warning: unable to parse metadata...")

    return metadata


def getCdTrackList(cd_device, track_count_offset):
    """Try to get a track listing from musicbrainz.
    If none found, generate a generic track listing starting from track_count_offset
    """

    # Query the disc for disc info, and use the info to query musicbrainz

    (disc_id, num_tracks) = getCdInfo(cd_device)

    print("Num tracks: %d" % num_tracks)
    # Populate a structure of lists to return to the user
    # (may be extended if more info is needed from the cddb lookup)
    track_list = []

    metadata = getCdMetaData(disc_id)

    # If we found a match...
    if metadata:
        print("Using metadata: " + metadata.get_album_title())

        num_tracks_metadata = len(metadata.get_track_titles())

        if num_tracks != num_tracks_metadata:
            print("Error: actual cd has %d tracks, but metadata from database %d tracks" % (num_tracks, num_tracks_metadata))
            sys.exit(1)

        for track_title in metadata.get_track_titles():
            track_list.append(track_title)

    # We didn't find a match... generate the track listing manually
    else:
        print("Using generic track names")
        for i in range(1, num_tracks + 1):
            track_list.append("Track %d" % (i + track_count_offset))

    return track_list


# NOTE: not sure there's any advantage between these backends
# (icedax (cdrkit) was a fork of cdda2wav (cdrtools) a while back)
# supposedly the cdrtools cdda2wav some some advantages over the below,
# (see: https://unix.stackexchange.com/questions/2442/how-to-rip-scratched-audio-cds)
# but it's not packaged by default on very many distros
class CdRipperInterface:
    """Interface for ripping cds, could put common code here"""
    pass


class CdParanoia(CdRipperInterface):
    def __init__(self, device, ignore_errors):
        """Interface to use cdparanoia"""
        self.device = device
        self.ignore_errors = ignore_errors

    def containsDiskCommand(self):
        return "cdparanoia -Q %s 2>/dev/null" % self._extraCommandArguments()

    def ripCommand(self, track_count, track_filename):
        return "cdparanoia %s --output-wav %d %s" % (self._extraCommandArguments(), track_count, shellQuote(track_filename))

    def _extraCommandArguments(self):
        """Private method to get some options"""
        options = ""

        if self.device:
            options += " -d " + shellQuote(self.device)

        if self.ignore_errors:
            options += " -Z "

        return options


class IceDax(CdRipperInterface):
    def __init__(self, device, ignore_errors):
        """Interface to use icedax"""
        self.device = device
        self.ignore_errors = ignore_errors

    def containsDiskCommand(self):
        # TODO: is there a awy to use icedax to do this?
        # return "icedax --info-only --verbose-level summary %s 2>/dev/null" % self._extraCommandArguments()
        # that works if there's a disc in the drive, but if not, it prompts
        # TODO: replace this with python3-libdiscid?
        return "cd-discid %s > /dev/null" % self.device

    def ripCommand(self, track_count, track_filename):
        # NOTE: "--verbose-level titles" is to reduce output
        return "icedax %s --no-infofile --track %d --verbose-level titles %s" % (self._extraCommandArguments(), track_count, shellQuote(track_filename))

    def _extraCommandArguments(self):
        """Private method to get some options"""

        # options = " -g " # More easily parsable output?
        options = ""

        if self.device:
            options += " -device " + shellQuote(self.device)

        if not self.ignore_errors:
            # uses libparanoia
            options += " -paranoia "

        return options


def RipperFactory(name):
    if name == "cdparanoia":
        return CdParanoia
    elif name == "icedax":
        return IceDax
    else:
        print("Invalid cd ripper: " + name)
        raise


# Rip an audiobook consisting of multiple cds to wav files, one file per track on each disc

# Then, use the combine_and_encode to encode to a single audiobook

# Optionally use gen_chapter_list to generate chapter information for m4b files, injected with set_chapters

# This needs to be run in it's own temporary directory, otherwise it really clouds things up.

def interactivelyRipCds(output, cd_device, ignore_errors, cd_backend, disc_count, total_track_count):

    if not os.path.exists(output):
        os.mkdir(output)
    os.chdir(output)

    ripper = RipperFactory(cd_backend)(cd_device, ignore_errors)

    detect_command = ripper.containsDiskCommand()

    while True:
        askQuestion("Insert disc %d and press <ENTER> when ready" % disc_count)

        # Don't start until we know there's a disc in the drive
        poll_count = 0
        ret = 1
        while ret != 0:
            print("Looking for disc...")
            if poll_count > 30:
                print("Error: Could not find audio disc")
                sys.exit(1)
            ret = os.system(detect_command)
            time.sleep(1)
            poll_count += 1

        # sleep for another 10 seconds to wait for auto insert access to calm down
        time.sleep(10)

        track_list = getCdTrackList(cd_device, total_track_count)
        total_track_count += len(track_list)
        track_count = 1

        for track_name in track_list:
            track_filename = '%.2d-%.2d-%s.wav' % (disc_count, track_count, track_name)
            print("Track filename: " + track_name)

            rip_track = True
            # Default is to skip if the file exists
            if os.path.exists(track_filename) and not re.search("o", askQuestion("%s exists.  Skip or Overwrite? [So]" % track_filename), re.IGNORECASE):
                rip_track = False

            if rip_track:
                command_to_run = ripper.ripCommand(track_count, track_filename)
                runOrDie(command_to_run)

                # Testing
                # print "Running command: " + command_to_run
                # os.system("touch %s" % shellQuote(track_filename))

            track_count += 1

        runOrDie("eject %s" % (shellQuote(cd_device) if cd_device else ""))
        disc_count += 1

        if re.search("(n|no)", askQuestion("Continue with disk %d? [Yn]" % disc_count), re.IGNORECASE):
            break


# generate a chapter listing to stdout that can be imported via mp4chaps

# The idea is to get a generated listing, and then hack up the file,
# and then use mp4chaps to import to a file created with files_to_audiobooks

# Format: 00:00:00.000 Chapter 1
# TODO: break up chapter lists for resulting m4b files over the sample limit
def genChapterList(files, chapter_format, out_file="", tempo=1.0):

    # sort the files, just in case
    files.sort()

    cl = ChapterListFactory(chapter_format=chapter_format)

    for f in files:
        print("Adding file to chapter list: " + f)
        cl.addChapterFromFile(f, tempo)

    if len(out_file) > 0:
        cl.toFile(out_file)

    return cl


def convertChapterList(chapter_file, chapter_format, new_chapter_file, new_chapter_format):
    cl = ChapterListFactory(chapter_format=chapter_format)
    cl.populateFromChapterFile(chapter_file)

    new_cl = ChapterListFactory(chapter_format=new_chapter_format)

    for i in range(1, cl.size() + 1):
        new_cl.addChapter(cl.getChapter(i))

    new_cl.toFile(new_chapter_file)


def buildFilesString(files):
    ret = ""
    for f in files:
        ret += " %s" % shellQuote(f)
    return ret


# Combines a bunch of audio files to a single mp3, m4b, or ogg audiobook
#  Supports any audio files supported by ffmpeg
#  Do this in one pass to avoid a path using intermediate files going to wav, raw, and then output
#  There is a lossy conversion, but for an audiobook, oh well...

# TODO: warn user if outputting to m4b file will have over
#  2 billion samples, or whatever the ipod limitation is... ugh
#  http://groups.google.com/group/macvisionaries/msg/f4acb49721b51834
#  could split files at known boundary to avoid the problem
#  2 bil / 22050 samples = 194783 seconds
#  = 54 hours.  Is that really our maximum?  Should be fine for most books... ?
#  -> roughly 775 m4b file is the maximum
#  Or is it 4 billion / 22050 = 108 hours?
#  -> 64:43 book had problems.  Chapters appeared fine, but iphone ipod app crashed
#     when it tried to play it (or scroll the chapters)

# TODO: incorporate gen_chapter_list for m4b files that must be broken up
def encodeFiles(output, output_extension, in_files, ffmpeg_input_options, tempo):

    for f in in_files:
        exitIfMissing(f)

    if output_extension not in ffmpeg_output_profiles:
        print("Error: '%s' is of unknown resulting file format: %s" % (output, output_extension))
        sys.exit(1)

    # Pick ffmpeg output parameters based on output filetype
    output_codec = ffmpeg_output_profiles[output_extension]['codec']
    codec_options = ffmpeg_output_profiles[output_extension]['options']
    output_format = ffmpeg_output_profiles[output_extension]['format']
    output_rate = ffmpeg_output_profiles[output_extension]['sample_rate']

    error_filename = "/tmp/audiobook_tool_error.%s" % os.getpid()

    # Set up sox pipe for tempo option
    sox_pipe = ""
    if tempo != 1.0:
        # tempo segment of 30 (recommended for speech)
        sox_pipe = "| sox -L -t s2 -r %s -c %s - -L -t s2 -r %s -c %s - tempo %s 30" % (output_rate, output_channels, output_rate, output_channels, tempo)

    # Command to loop through all the input files and output to stdout
    #  Use the output rate and channels to cut down on conversions
    #  (note: a fifo was attempted, but the fifo would randomly close prematurely)
    #  Use a tmp file to carry the error code through the pipe
    intermediate_format_options = "-ar %s -ac %s -f s16le" % (output_rate, output_channels)
    # TODO: gather length by converting to a wav, getting the size via sox, piping with ffmpeg, and then cleaning up the wav file?
    #  that "could" be faster overall, even though it would slow down this step (writing each wav file to disc)
    player_command = "for i in %s ; do echo \"Encoding $i\" >&2; %s %s -y -i \"$i\" %s %s - %s || { echo '' >&2; echo \"****** Failed to decode $i ******\" >&2 ; echo '' >&2 ; touch %s ; exit 1 ; } ; done""" % (buildFilesString(in_files), ffmpeg_program, ffmpeg_verbosity, ffmpeg_input_options, intermediate_format_options, null_pipe, shellQuote(error_filename))

    # Now run the command to convert all data coming from stdin
    output_format_options = "-acodec %s %s -ar %s -ab %s -ac %s -f %s" % (output_codec, codec_options, output_rate, output_bitrate, output_channels, output_format)
    runOrDie("rm -f %s ; ( %s ) %s | %s %s -y %s -i - %s %s %s" % (shellQuote(error_filename), player_command, sox_pipe, ffmpeg_program, ffmpeg_verbosity, intermediate_format_options, output_format_options, shellQuote(output), null_pipe), error_message="Encoding failed")

    if os.path.exists(error_filename):
        print("")
        print("Failed to decode input files!")
        print("")
        print("Suggestion: specify ffmpeg input options with '--ffmpeg_input_format_options'")
        print("")
        print("  Note: these options will be applied to _all_ input files")
        print("")
        print("Suggestion 2: try manually converting that one file with another tool to a .wav file and use it to replace the broken input file")
        print("")
        print("  ie: mplayer <file unreadable by ffmpeg> -ao pcm:file=tmp.wav; ffmpeg -y -i tmp.wav -f wav out.wav")
        print("")
        print("  Doing the second conversion with ffmpeg probably won't make a difference except for the paranoid")
        print("")
        print("Suggestion 3: Use mythffmpeg instead of ffmpeg by adjusting ffmpeg_program at the top of this file")
        print("")
        os.unlink(error_filename)
        sys.exit(1)

    print("Success!")


def combineAndEncode(output, in_files, ffmpeg_input_options="", tempo=1.0):
    # Get output file extension
    output_extension = os.path.splitext(output)[1]

    encodeFiles(output, output_extension, in_files, ffmpeg_input_options, tempo)


def reEncode(output_dir, audio_ext, in_files, ffmpeg_input_options, tempo):
    """Encode a bunch of files"""

    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

    # Encode each individually
    for f in in_files:

        # New filename
        [basename, extension] = os.path.splitext(f)
        output_file = output_dir + os.sep + basename + audio_ext

        encodeFiles(output_file, audio_ext, [f], ffmpeg_input_options, tempo)

        if extension == audio_ext:
            copyMetaData(f, output_file)
        else:
            print("Warning: Copying metadata between differing formats is unsupported")


def playChapterSample(chapter_txt, audio_file, chapter_index, offset=0.0):
    """Easily play at a spot in a chapter to assist in verifying all chapter marks"""

    exitIfMissing(chapter_txt)
    exitIfMissing(audio_file)

    cl = ChapterListFactory(filename=audio_file)

    try:
        cl.populateFromChapterFile(chapter_txt)
    except Exception:
        print("Error: unable to parse chapter list: " + chapter_txt)
        sys.exit(1)

    chaps = []
    if not chapter_index:
        chaps.extend(list(range(1, cl.size() + 1)))
    else:
        # turn "1,3-5,7,9-11" into [1, 3, 4, 5, 7, 9, 10, 11]
        for chap_range in chapter_index.split(','):
            chap_boundaries = chap_range.split('-')
            chaps.extend(list(range(int(chap_boundaries[0]), int(chap_boundaries[len(chap_boundaries) - 1]) + 1)))
    for i in chaps:
        chapter = cl.getChapter(i)

        # is mplayer accurate when it comes to seeking? (ie: does it match seeking with chapters with Apple's software?)
        #  -> doing some rough checks, it appears to match quicktime on windows

        #  Documentation says it only seeks to second boundaries, but seeking to fractional seconds works
        print("Playing chapter %d (%s)" % (i, chapter.name))

        # Different methods to play the file
        # TODO: add back play duration support (I think only mplayer supports this)
        #  Idea being you can play each track for 1 second to easily scan them
        runOrDie("mplayer -ss %.3f %s >/dev/null 2>&1" % (chapter.timeMark + offset, shellQuote(audio_file)))

        # runOrDie("ffplay -ss %.3f %s 2>/dev/null" % (chapter.timeMark + offset, shellQuote(audio_file)))


def adjustChapter(chapter_format, chapter_txt, chapter_index, seconds, cascade):

    exitIfMissing(chapter_txt)

    cl = ChapterListFactory(chapter_format=chapter_format)

    cl.populateFromChapterFile(chapter_txt)

    cl.adjustChapterTimeMark(chapter_index, seconds, cascade)

    cl.toFile(chapter_txt)


def setChapterTempo(chapter_format, chapter_txt, tempo):

    exitIfMissing(chapter_txt)

    cl = ChapterListFactory(chapter_format=chapter_format)

    cl.populateFromChapterFile(chapter_txt)

    cl.adjustTempo(tempo)

    cl.toFile(chapter_txt)


def removeChapter(chapter_format, chapter_txt, index):

    exitIfMissing(chapter_txt)

    cl = ChapterListFactory(chapter_format=chapter_format)

    cl.populateFromChapterFile(chapter_txt)

    cl.removeChapter(index)

    cl.toFile(chapter_txt)


class AudioBook:
    def __init__(self, audio_file):
        self.audio_file = audio_file

    def setChapters(self, chapter_txt):
        exitIfMissing(self.audio_file)
        exitIfMissing(chapter_txt)

    def getChapters(self):
        exitIfMissing(self.audio_file)

        cl = self.chapter_list_type()

        cl.populateFromAudioFile(self.audio_file)

        return cl

    def setMetaData(self):
        exitIfMissing(self.audio_file)

    def setCoverArt(self):
        exitIfMissing(self.audio_file)

    def postProcess(self):
        exitIfMissing(self.audio_file)

    def fromFiles(self, author, title, art_file, in_files, ffmpeg_input_format_options="", tempo=1.0):
        """All-in-one method to generate a book once all the necessary information is given."""

        # Get the chapter name
        chapter_txt = os.path.splitext(self.audio_file)[0] + ".chapters.txt"

        # Do this option first since it will catch the error of invalid resulting extension.
        # Otherwise, all the chapters are generated, which takes some time, only to fail on this step
        combineAndEncode(self.audio_file, in_files, ffmpeg_input_format_options, tempo)

        genChapterList(in_files, self.chapter_format, chapter_txt, tempo)

        # TODO: break up the chapter lists and combining/encoding if it exceeds the m4b max sample count

        self.setChapters(chapter_txt)
        self.setMetaData(author, title)
        self.setCoverArt(art_file)
        self.postProcess()

        print("Success!")

    def getMetaData(self):
        exitIfMissing(self.audio_file)

    def getCoverArt(self):
        exitIfMissing(self.audio_file)


class M4bAudioBook(AudioBook):
    def __init__(self, audio_file):
        AudioBook.__init__(self, audio_file)
        self.chapter_list_type = M4bChapterList
        self.chapter_format = "m4b"

    def setChapters(self, chapter_txt):

        AudioBook.setChapters(self, chapter_txt)

        # mp4v2 seems to break when there are 2 chapters in a row with the same timestamp.
        #  this can be worked around by adding a millisecond difference
        #  A check should be added to make sure there are no chapters with duplicate timestamps
        #  -> but, the ipod freaks out from tiny chapters.  Just prepend the chapter with some
        #  text instead of adding an additional chapter.

        # Remove all chapters
        #  (fails if list doesn't exist... oh well)
        os.system("mp4chaps --remove %s" % shellQuote(self.audio_file))

        # Put correct chapter file in place if needs be, and clean up afterwards
        #  (TODO: if mp4v2 every gets python bindings, we won't have to do this kind of work around)
        tool_expected_chapter_file = os.path.splitext(self.audio_file)[0] + ".chapters.txt"
        cleanup = False
        if tool_expected_chapter_file != chapter_txt:
            shutil.copyfile(chapter_txt, tool_expected_chapter_file)
            cleanup = True

        # Inject chapters
        runOrDie("mp4chaps --import %s" % shellQuote(self.audio_file))

        if cleanup:
            os.unlink(tool_expected_chapter_file)

    def setMetaData(self, author, title, trackTitle=""):

        AudioBook.setMetaData(self)

        # Set track title to title if no track title was passed in
        if trackTitle == "":
            trackTitle = title

        # Set author and title (TODO: more info?)
        #  Use double quotes so apostraphes can be used in titles
        # Itunes audiobooks uses the album as the top level tree, and then the title in the subtree.
        #  TODO: maybe have optional title (song) for when books must be split into two
        runOrDie("mp4tags -i audiobook -artist %s -album %s -song %s %s" % (shellQuote(author), shellQuote(title), shellQuote(trackTitle), shellQuote(self.audio_file)))

    def setCoverArt(self, image_file):

        AudioBook.setCoverArt(self)

        exitIfMissing(image_file)

        # Set/Replace Coverart
        # (fails if no art is set... oh well)
        os.system("mp4art --remove %s" % shellQuote(self.audio_file))
        runOrDie("mp4art --add %s %s" % (shellQuote(image_file), shellQuote(self.audio_file)))

    def postProcess(self):

        AudioBook.postProcess(self)

        # PostProcess
        # -> optimizes mp4 file for http streaming
        runOrDie("mp4file --optimize %s" % (shellQuote(self.audio_file)))

    def getMetaData(self):

        AudioBook.getMetaData(self)

        author = ""
        title = ""
        trackTitle = ""

        (status, output) = subprocess.getstatusoutput("mp4info %s" % shellQuote(self.audio_file))

        for line in output.split("\n"):
            title_ret = re.search(" Name: (.*)", line)
            author_ret = re.search(" (Artist|Author): (.*)", line)
            trackTitle_ret = re.search(" Album: (.*)", line)

            if title_ret:
                title = title_ret.group(1)
            elif author_ret:
                if not author and author_ret.group(2):
                    author = author_ret.group(2)
            elif trackTitle_ret:
                trackTitle = trackTitle_ret.group(1)

        if author and title:
            return (author, title, trackTitle)
        else:
            print("Error getting metadata from: " + self.audio_file)
            sys.exit(1)

    def getCoverArt(self):

        AudioBook.getCoverArt(self)

        # Get Coverart
        os.system("mp4art --overwrite --force --extract %s" % shellQuote(self.audio_file))

        files = []

        # TODO: what other extensions?
        for ext in ['jpg', 'png']:
            files += glob.glob(os.path.splitext(self.audio_file)[0] + ".art*." + ext)

        return files


class MkaAudioBook(AudioBook):
    def __init__(self, audio_file):
        AudioBook.__init__(self, audio_file)
        self.chapter_list_type = MkaChapterList
        self.chapter_format = "mka"

    def setChapters(self, chapter_txt):

        AudioBook.setChapters(self, chapter_txt)

        # Inject chapters
        runOrDie("mkvpropedit %s --chapters %s" % (shellQuote(self.audio_file), shellQuote(chapter_txt)))

    def setMetaData(self, author, title, trackTitle=""):

        AudioBook.setMetaData(self)

        # Set track title to title if no track title was passed in
        if trackTitle == "":
            trackTitle = title

        # Seems artist can only be set via "tags"
        # Ugly, but oh well
        # These are "global" tags
        # Reference: https://www.matroska.org/technical/tagging.html
        # NOTE: tag keys "should" be all caps
        tags_content = """
        <Tags>
          <Tag>
            <Targets>
              <TargetTypeValue>50</TargetTypeValue>
            </Targets>
            <Simple>
              <Name>ARTIST</Name>
              <String>%s</String>
            </Simple>
          </Tag>
        </Tags>
        """ % author

        xml_filename = self.audio_file + ".xml"

        fd = open(xml_filename, 'w')
        fd.write(tags_content)
        fd.close()

        # Use the extension in the temp filename since mkvmerge bases some decisions on it (ie: webm)
        extension = os.path.splitext(self.audio_file)[1]

        temp_filename = self.audio_file + ".tmp" + extension

        #  Use double quotes so apostraphes can be used in titles
        # NOTE: mkvpropedit accepts setting tags, but it seems to produce a file that makes metadata unrecognizable from players
        # Not sure if that's a bug or what...
        # Use mkvmerge instead to work around this (luckily it runs pretty quickly)
        # NOTE: "--track-name" needs to go before the input filename (and id starts at 0)
        #  see: https://www.reddit.com/r/mkvtoolnix/comments/g8h8vm/mkvmerge_set_multiple_track_names/
        runOrDie("mkvmerge --title %s --no-video --global-tags %s --output %s --track-name 0:%s %s" % (shellQuote(title), shellQuote(xml_filename), shellQuote(temp_filename), shellQuote(trackTitle), shellQuote(self.audio_file)))

        # Replace original file with new file
        runOrDie("mv %s %s" % (shellQuote(temp_filename), shellQuote(self.audio_file)))

        # Clean up
        os.unlink(xml_filename)

    def setCoverArt(self, image_file):

        AudioBook.setCoverArt(self)

        exitIfMissing(image_file)

        # Set/Replace Coverart
        # TODO: there needs to be some coordination on how to set cover art for matroska
        os.system("mkvpropedit %s --delete-attachment 1" % (shellQuote(self.audio_file)))
        runOrDie("mkvpropedit %s --attachment-name cover --add-attachment %s" % (shellQuote(self.audio_file), shellQuote(image_file)))

    def postProcess(self):

        AudioBook.postProcess(self)

        print("postProcess: unnecessary for mka")

    def getMetaData(self):

        AudioBook.getMetaData(self)

        author = ""
        title = ""
        trackTitle = ""  # TODO

        # First the info
        (status, output) = subprocess.getstatusoutput("mkvinfo %s" % shellQuote(self.audio_file))

        for line in output.split("\n"):
            title_ret = re.search("Title: (.*)", line)

            if title_ret:
                title = title_ret.group(1)
                trackTitle = title

        # Now for the tags
        (status, xml_output) = subprocess.getstatusoutput("mkvextract tags %s" % shellQuote(self.audio_file))

        try:
            # Get the artist
            root = xml.etree.ElementTree.fromstring(xml_output)
            # NOTE: these tags are case sensitive!
            for e in root.findall('.//Simple'):
                name = e.find('Name').text
                value = e.find('String').text
                if name.lower() == "artist":
                    author = value
        except Exception:
            pass

        # TODO: add support for querying track title

        if author and title:
            return (author, title, trackTitle)
        else:
            print("Error getting metadata from: " + self.audio_file)
            sys.exit(1)

    def getCoverArt(self):

        AudioBook.getCoverArt(self)

        # Get Coverart
        # NOTE: this just gets them from where we put them
        # We could go through all attachments looking for image mime-types
        os.system("mkvextract attachments %s 1:cover.jpg " % shellQuote(self.audio_file))

        if os.path.exists("cover.jpg"):
            return ["cover.jpg"]
        else:
            return [""]


class FLACPicture:
    def __init__(self):

        # Based on:
        # https://github.com/quodlibet/mutagen/commit/301708ac25f96a2676e15ce9e0fcf5f49439bfb4

        pass

    @staticmethod
    def mime_type(pil_format):
        ret = "image/"  # default for everything else
        if pil_format == 'JPEG':
            ret = 'image/jpeg'
        elif pil_format == 'PNG':
            ret = 'image/png'
        else:
            print("Error, unknown mime type for: " + pil_format)

        return ret

    @staticmethod
    def file_extension(mime_type):
        ret = "unknown"
        if mime_type == 'image/jpeg':
            ret = 'jpg'
        elif mime_type == 'image/png':
            ret = 'png'
        else:
            print("Error, unknown file extension for: " + mime_type)

        return ret

    @staticmethod
    def depth(pil_mode):

        # https://stackoverflow.com/questions/1996577/how-can-i-get-the-depth-of-a-jpg-file
        mode_to_bpp = {
            '1':      1,
            'L':      8,
            'P':      8,
            'RGB':   24,
            'RGBA':  32,
            'CMYK':  32,
            'YCbCr': 24,
            'I':     32,
            'F':     32,
        }

        if pil_mode in mode_to_bpp:
            return mode_to_bpp[pil_mode]
        else:
            print("Unknown depth from mode: " + pil_mode)
            return 0

    def encode(self, filename):

        # TODO: strange?  Don't want all book types to depend on these imports...
        import mutagen.flac
        import PIL.Image

        pil_image = PIL.Image.open(filename)

        picture = mutagen.flac.Picture()

        picture.data = open(filename, 'rb').read()
        picture.type = 3  # cover art
        picture.desc = 'audio book cover art'
        picture.mime = self.mime_type(pil_image.format)
        picture.width, picture.height = pil_image.size
        picture.depth = self.depth(pil_image.mode)

        picture_data = picture.write()
        encoded_data = base64.b64encode(picture_data).decode('ascii')

        # TODO: use a logging module?
        print("Picture width: %d" % picture.width)
        print("Picture height: %d" % picture.height)
        print("Picture format: %s" % pil_image.format)
        print("Picture depth: %d" % picture.depth)

        return encoded_data

    def decode(self, encoded):
        import mutagen.flac

        decoded = base64.b64decode(encoded)

        picture = mutagen.flac.Picture(decoded)

        return (self.file_extension(picture.mime), picture.data)


class MutagenAudioBook(AudioBook):
    """Really just supports types that support ogg/vorbis comment chapters at this point"""

    def __init__(self, audio_file):
        AudioBook.__init__(self, audio_file)

    def _loadBook(self):

        self.mutagen_book = self.mutagen_type(self.audio_file)

    def _saveBook(self):

        self.mutagen_book.save()

    def _populateTagsFromFile(self, filename):

        contents = open(filename).read()

        self._populateTagsFromText(contents)

    def _populateTagsFromText(self, text):

        for line in text.split("\n"):
            if line.count('=') > 0:
                (key, value) = line.split('=')
                self.mutagen_book[key] = value
            elif len(line) == 0:  # Ignore blank lines
                pass
            else:
                print("Unexpected line from key/value: '{}'".format(line))

    def _removeChapterTags(self):
        """Remove all the chapter tags since they are about to get replaced"""
        for key in self.mutagen_book.keys():
            if key.startswith("chapter"):  # Not sure why this is lowercase?
                del self.mutagen_book[key]

    def setChapters(self, chapter_txt):

        AudioBook.setChapters(self, chapter_txt)

        self._loadBook()

        # Need to remove all chapter tags
        # mainly so if the new chapter list has fewer chapters there's not leftovers
        self._removeChapterTags()

        self._populateTagsFromFile(chapter_txt)

        self._saveBook()

    def setMetaData(self, author, title, trackTitle=""):

        AudioBook.setMetaData(self)

        self._loadBook()

        # Set track title to title if no track title was passed in
        if trackTitle == "":
            trackTitle = title

        self.mutagen_book['ARTIST'] = author
        self.mutagen_book['ALBUM'] = title
        self.mutagen_book['TITLE'] = trackTitle

        self._saveBook()

    def setCoverArt(self, image_file):

        AudioBook.setCoverArt(self)

        self._loadBook()

        # https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE
        # https://xiph.org/flac/format.html#metadata_block_picture
        # https://github.com/quodlibet/mutagen/commit/301708ac25f96a2676e15ce9e0fcf5f49439bfb4

        exitIfMissing(image_file)

        image = FLACPicture()

        self.mutagen_book['METADATA_BLOCK_PICTURE'] = [image.encode(image_file)]

        self._saveBook()

    def postProcess(self):

        AudioBook.postProcess(self)

        print("postProcess: unnecessary for " + self.chapter_format)

    def getMetaData(self):

        AudioBook.getMetaData(self)

        author = ""
        title = ""
        trackTitle = ""

        self._loadBook()


        try:
            if 'ARTIST' in self.mutagen_book:
                author = self.mutagen_book['ARTIST'][0]
            if 'ALBUM' in self.mutagen_book:
                title = self.mutagen_book['ALBUM'][0]
            if 'TITLE' in self.mutagen_book:
                trackTitle = self.mutagen_book['TITLE'][0]
        except IndexError as e:
            print("Programming error getting metadata from: {}: {}".format(self.audio_file, e));
            sys.exit(1)
        except Exception as e:
            raise e

        if author and title:
            return (author, title, trackTitle)
        else:
            print("Error getting metadata from: " + self.audio_file)
            sys.exit(1)

    def getCoverArt(self):

        AudioBook.getCoverArt(self)

        self._loadBook()

        image_names = []

        if 'METADATA_BLOCK_PICTURE' in self.mutagen_book:

            # Just for generating filenames...
            count = 0
            for encoded_image in self.mutagen_book['METADATA_BLOCK_PICTURE']:
                image = FLACPicture()
                (extension, data) = image.decode(encoded_image)
                image_filename = "cover%d.%s" % (count, extension)
                open(image_filename, 'wb').write(data)
                image_names += [image_filename]
                count += 1

        else:
            print('Book does not contain cover art')

        return image_names


class OggAudioBook(MutagenAudioBook):
    def __init__(self, audio_file):
        MutagenAudioBook.__init__(self, audio_file)
        self.chapter_list_type = OggChapterList
        self.chapter_format = "ogg"

        import mutagen.oggvorbis
        self.mutagen_type = mutagen.oggvorbis.OggVorbis


class OpusAudioBook(MutagenAudioBook):
    def __init__(self, audio_file):
        MutagenAudioBook.__init__(self, audio_file)
        self.chapter_list_type = OpusChapterList
        self.chapter_format = "opus"

        import mutagen.oggopus
        self.mutagen_type = mutagen.oggopus.OggOpus


class MP3AudioBook(MutagenAudioBook):
    def __init__(self, audio_file):
        MutagenAudioBook.__init__(self, audio_file)
        self.chapter_list_type = MP3ChapterList
        self.chapter_format = "mp3"

        import mutagen.easyid3
        self.mutagen_type = mutagen.easyid3.EasyID3

    def _saveBook(self):
        """Override because the mp3 version requires the v2_version argument"""

        # Defaults to 4, but doesn't seem to be widely used, so just use version 3
        self.mutagen_book.save(v2_version=3)


def copyMetaData(in_file, out_file):
    """Read the metadata from the input file and copy to the output file"""

    # Get all the metadata
    src_cl = ChapterListFactory(filename=in_file)
    src_cl.populateFromAudioFile(in_file)

    in_book = AudioBookFactory(in_file)
    (author, title, trackTitle) = in_book.getMetaData()
    # Usually only one art file
    art_files = in_book.getCoverArt()

    # TODO: what if in/out are different types?  Need to convert chapter objects
    dest_cl = src_cl

    basename = os.path.splitext(out_file)[0]
    chapter_txt = basename + ".chapters.txt"
    dest_cl.toFile(chapter_txt)

    out_book = AudioBookFactory(out_file)

    # Set the metadata
    out_book.setChapters(chapter_txt)
    os.unlink(chapter_txt)
    out_book.setMetaData(author, title, trackTitle)
    # Don't fail of no coverart found
    if len(art_files) > 0:
        out_book.setCoverArt(art_files[0])
        os.unlink(art_files[0])
    out_book.postProcess()


def setTempo(audio_file, in_file, ffmpeg_input_format_options="", tempo=1.0):
    """Re-encode file to another tempo (for devices that can't do it on the fly: android)
    Basically the same as combine_and_encode except it preserves metadata and adjusts chapters"""

    # Re-encode
    combineAndEncode(audio_file, [in_file], ffmpeg_input_format_options, tempo)

    copyMetaData(in_file, audio_file)

    # Set Tempo for chapters
    cl = ChapterListFactory(filename=audio_file)
    cl.populateFromAudioFile(audio_file)

    # adjust the chapters and save out to file
    cl.adjustTempo(tempo)

    basename = os.path.splitext(audio_file)[0]
    chapter_txt = basename + ".chapters.txt"
    cl.toFile(chapter_txt)

    out_book = AudioBookFactory(audio_file)

    # Set the new chapters
    out_book.setChapters(chapter_txt)
    os.unlink(chapter_txt)
    out_book.postProcess()

    print("Success!")


def extractTracks(audio_file, chapter_format, chapter_file, output_dir):
    """Extract tracks based on chapters.  Useful to create 'mp3 cds' from a book file"""

    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

    if chapter_format == "":
        chapter_format = os.path.splitext(audio_file)[1]

    # Get all the metadata
    if chapter_file != "":
        cl = ChapterListFactory(chapter_format=chapter_format)
        cl.populateFromChapterFile(chapter_file)
    else:
        cl = ChapterListFactory(filename=audio_file)
        cl.populateFromAudioFile(audio_file)

    # For all of the chapters (one based)
    for i in range(1, cl.size() + 1):

        # Use lossless format, as usually this is an intermediate format
        chapter_out_file = output_dir + os.sep + "%03d" % (i) + "-track.flac"

        # Run ffmpeg command to extract track
        chapter = cl.getChapter(i)

        start_time_options = " -ss " + chapter.timeString()

        end_time_options = ""
        # Don't need end time on last chapter
        if i != cl.size():
            end_time_options = " -to " + cl.getChapter(i + 1).timeString()

        command = "ffmpeg -y -i " + shellQuote(audio_file) + start_time_options + end_time_options + " " + shellQuote(chapter_out_file)

        runOrDie(command)


def validateDependencies(progs):

    for p in progs:
        (status, output) = subprocess.getstatusoutput("which " + p)
        if status != 0:
            print("Warning: %s not found" % p)


if __name__ == "__main__":

    # Check for command line dependencies (only warn user)
    validateDependencies(list(cmd_line_dependencies.keys()))

    parser = argparse.ArgumentParser(prog='audiobook_tool')
    subparsers = parser.add_subparsers(dest='subcommand')

    # --- rip_cds ---
    parser_rip_cds = subparsers.add_parser("rip_cds", help="Rip CDs into audio files.")
    parser_rip_cds.add_argument("output", help="Directory to store ripped tracks.")
    parser_rip_cds.add_argument("--cd_device", help="CD device to use.")
    parser_rip_cds.add_argument("--ignore_errors", action="store_true", help="Ignore read errors.")
    parser_rip_cds.add_argument("--backend", choices=["cdparanoia", "icedax"], default="cdparanoia", help="CD backend to use.")
    parser_rip_cds.add_argument("disc_number", nargs="?", type=int, default=1, help="Disc number (optional).")
    parser_rip_cds.add_argument("num_previous_tracks", nargs="?", type=int, default=0, help="Number of previous tracks (optional).")

    # --- combine_and_encode ---
    cae = subparsers.add_parser("combine_and_encode", help="Combine and encode audio files.")
    cae.add_argument("audio_file", help="Output audiobook file (e.g. Book.m4b).")
    cae.add_argument("in_files", nargs="+", help="Input audio files.")
    cae.add_argument("--ffmpeg_input_format_options", default="", help="FFmpeg input format options.")
    cae.add_argument("--tempo", type=float, default=1.0, help="Playback tempo ratio (e.g. 1.1 for 10%% faster).")

    # --- reencode ---
    reenc = subparsers.add_parser("reencode", help="Reencode audio files.")
    reenc.add_argument("output_dir", help="Output directory.")
    reenc.add_argument("audio_ext", choices=audio_extensions, help="Output audio format.")
    reenc.add_argument("in_files", nargs="+", help="Input audio files.")
    reenc.add_argument("--ffmpeg_input_format_options", default="", help="FFmpeg input format options.")
    reenc.add_argument("--tempo", type=float, default=1.0, help="Playback tempo ratio.")

    # --- gen_chapter_list ---
    gcl = subparsers.add_parser("gen_chapter_list", help="Generate a chapter list from audio files.")
    gcl.add_argument("chapter_file", help="Output chapter list file (e.g. Book.chapters.txt).")
    gcl.add_argument("in_files", nargs="+", help="Input audio files.")
    gcl.add_argument("--tempo", type=float, default=1.0, help="Playback tempo ratio.")
    gcl.add_argument("--format", choices=book_extensions, default="m4b", help="Output format extension.")

    # --- convert_chapter_list ---
    ccl = subparsers.add_parser("convert_chapter_list", help="Convert chapter list formats.")
    ccl.add_argument("chapter_file", help="Input chapter list.")
    ccl.add_argument("--format", required=True, choices=book_extensions, default="m4b", help="Input format.")
    ccl.add_argument("new_chapter_file", help="Output chapter list.")
    ccl.add_argument("--new_format", required=True, choices=book_extensions, default="m4b", help="Output format.")

    # --- play_chapter ---
    play = subparsers.add_parser("play_chapter", help="Play a specific chapter range from an audiobook.")
    play.add_argument("chapter_file", help="Chapter list file.")
    play.add_argument("book_file", help="Audiobook file.")
    play.add_argument("chapter_range", nargs="?", help='Chapter range (e.g. "7" or "1-3,6,8-10").')
    play.add_argument("offset", nargs="?", type=float, default=0.0, help="Start offset in seconds.")

    # --- adjust_chapter ---
    adj = subparsers.add_parser("adjust_chapter", help="Adjust chapter timing.")
    adj.add_argument("chapter_file", help="Chapter list file.")
    adj.add_argument("chapter_index", type=int, help="Chapter index to adjust.")
    adj.add_argument("--format", choices=book_extensions, default="m4b", help="Book format.")
    adj.add_argument("--cascade", action="store_true", help="Cascade timing adjustment to following chapters.")
    adj.add_argument("seconds", type=float, help="Seconds to shift (can be negative, e.g. -2.5).")

    # --- set_chapter_tempo ---
    sct = subparsers.add_parser("set_chapter_tempo", help="Set playback tempo for a chapter list.")
    sct.add_argument("chapter_file", help="Chapter list file.")
    sct.add_argument("tempo", type=float, help="Tempo ratio.")
    sct.add_argument("--format", choices=book_extensions, default="m4b", help="Book format.")

    # --- remove_chapter ---
    rc = subparsers.add_parser("remove_chapter", help="Remove a chapter from a list.")
    rc.add_argument("chapter_file", help="Chapter list file.")
    rc.add_argument("chapter_index", type=int, help="Chapter index to remove.")
    rc.add_argument("--format", choices=book_extensions, default="m4b", help="Book format.")

    # --- set_chapters ---
    setc = subparsers.add_parser("set_chapters", help="Set chapters into audiobook.")
    setc.add_argument("book_file", help="Audiobook file.")
    setc.add_argument("chapter_file", help="Chapter list file.")

    # --- get_chapters ---
    getc = subparsers.add_parser("get_chapters", help="Extract chapters from audiobook.")
    getc.add_argument("book_file", help="Audiobook file.")
    getc.add_argument("chapter_file", help="Output chapter list file.")

    # --- set_metadata ---
    smd = subparsers.add_parser("set_metadata", help="Set metadata for audiobook.")
    smd.add_argument("book_file", help="Audiobook file.")
    smd.add_argument("author", help="Author name.")
    smd.add_argument("title", help="Book title.")
    smd.add_argument("track_title", nargs="?", help="Track title (optional).")

    # --- get_metadata ---
    gmd = subparsers.add_parser("get_metadata", help="Get metadata from audiobook.")
    gmd.add_argument("book_file", help="Audiobook file.")

    # --- set_coverart ---
    sca = subparsers.add_parser("set_coverart", help="Set cover art for audiobook.")
    sca.add_argument("book_file", help="Audiobook file.")
    sca.add_argument("image_file", help="Cover image file.")

    # --- get_coverart ---
    gca = subparsers.add_parser("get_coverart", help="Get cover art from audiobook.")
    gca.add_argument("book_file", help="Audiobook file.")

    # --- post_process ---
    pp = subparsers.add_parser("post_process", help="Run post-processing on audiobook.")
    pp.add_argument("book_file", help="Audiobook file.")

    # --- book_from_files ---
    bff = subparsers.add_parser("book_from_files", help="Build audiobook from files.")
    bff.add_argument("book_file", help="Output audiobook file.")
    bff.add_argument("author", help="Author name.")
    bff.add_argument("title", help="Book title.")
    bff.add_argument("image_file", help="Cover art image.")
    bff.add_argument("in_files", nargs="+", help="Input audio files.")
    bff.add_argument("--ffmpeg_input_format_options", default="", help="FFmpeg input format options.")
    bff.add_argument("--tempo", type=float, default=1.0, help="Playback tempo ratio.")

    # --- set_book_tempo ---
    sbt = subparsers.add_parser("set_book_tempo", help="Create new audiobook with adjusted tempo.")
    sbt.add_argument("book_file", help="Output audiobook file.")
    sbt.add_argument("in_book_file", help="Original audiobook file.")
    sbt.add_argument("--ffmpeg_input_format_options", default="", help="FFmpeg input format options.")
    sbt.add_argument("tempo", type=float, help="Tempo ratio.")

    # --- extract_tracks ---
    et = subparsers.add_parser("extract_tracks", help="Extract tracks from audiobook or audio file.")
    et.add_argument("audio_file", help="Audiobook or audio file.")
    et.add_argument("output_dir", help="Directory for extracted tracks.")
    et.add_argument("--chapter_file", help="Chapter list file.")
    et.add_argument("--chapter_format", choices=book_extensions, help="Chapter format.")

    args = parser.parse_args()

    # TODO: eventually we could use the python match statement

    # Parse and handle each of the sub-commands
    if 'rip_cds' == args.subcommand:

        # do some argument validation, since not sure if argparse can support dependant optional positional args
        if args.disc_number != 1 and args.num_previous_tracks == 0:
            print("Must set num_previous_tracks when resuming with disc_number")
            parser.print_help()
            sys.exit(1)

        interactivelyRipCds(args.output, args.cd_device, args.ignore_errors, args.backend, args.disc_number, args.num_previous_tracks)

    elif 'combine_and_encode' == args.subcommand:
        combineAndEncode(args.audio_file, args.in_files, args.ffmpeg_input_format_options, args.tempo)

    elif 'reencode' == args.subcommand:
        reEncode(args.output_dir, "." + args.audio_ext, args.in_files, args.ffmpeg_input_format_options, args.tempo)

    elif 'gen_chapter_list' == args.subcommand:
        genChapterList(args.in_files, args.format, args.chapter_file, args.tempo)

    elif 'convert_chapter_list' == args.subcommand:
        convertChapterList(args.chapter_file, args.format, args.new_chapter_file, args.new_format)

    elif 'play_chapter' == args.subcommand:
        if not re.search(r"^\d+(?:-\d+)?(?:,\d+(?:-\d+)?)*$", args.chapter_range):
            parser.print_help()
            sys.exit(1)

        playChapterSample(args.chapter_file, args.book_file, args.chapter_range, args.offset)

    elif 'adjust_chapter' == args.subcommand:
        adjustChapter(args.format, args.chapter_file, args.chapter_index, args.seconds, args.cascade)

    elif 'set_chapter_tempo' == args.subcommand:
        setChapterTempo(args.format, args.chapter_file, args.tempo)

    elif 'remove_chapter' == args.subcommand:
        removeChapter(args.format, args.hapter_file, args.chapter_index)

    elif 'set_chapters' == args.subcommand:
        book = AudioBookFactory(args.book_file)
        book.setChapters(args.chapter_file)

    elif 'get_chapters' == args.subcommand:
        book = AudioBookFactory(args.book_file)
        cl = book.getChapters()
        cl.toFile(args.chapter_file)

    elif 'set_metadata' == args.subcommand:
        book = AudioBookFactory(args.book_file)
        book.setMetaData(args.author, args.title, args.track_title)

    elif 'get_metadata' == args.subcommand:
        book = AudioBookFactory(args.book_file)

        (author, title, trackTitle) = book.getMetaData()

        print("Author: {}\nTitle: {}\nTrack Title: {}".format(author, title, trackTitle))

    elif 'set_coverart' == args.subcommand:
        book = AudioBookFactory(args.book_file)
        book.setCoverArt(args.image_file)

    elif 'get_coverart' == args.subcommand:
        book = AudioBookFactory(args.book_file)
        book.getCoverArt()

    elif 'post_process' == args.subcommand:
        book = AudioBookFactory(args.book_file)
        book.postProcess()

    elif 'book_from_files' == args.subcommand:
        book = AudioBookFactory(args.book_file)
        book.fromFiles(args.author, args.title, args.image_file, args.in_files, args.ffmpeg_input_format_options, args.tempo)

    elif 'set_book_tempo' == args.subcommand:
        setTempo(args.book_file, args.in_book_file, args.ffmpeg_input_format_options, args.tempo)

    elif 'extract_tracks' == args.subcommand:
        extractTracks(args.audio_file, args.chapter_format, args.chapter_file, args.output_dir)

    else:
        parser.print_help()
        sys.exit(1)

    sys.exit(0)


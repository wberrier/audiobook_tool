#!/usr/bin/env python

# Combines a bunch of audio files to a single mp3, m4b, or ogg audiobook
#  Supports any audio files supported by ffmpeg
#  Do this in one pass to avoid a path using intermediate files going to wav, raw, and then output
#  There is a lossy conversion, but for an audiobook, oh well...

# TODO: warn user if outputting to m4b file will have over
#  2 billion samples, or whatever the ipod limitation is... ugh
#  http://groups.google.com/group/macvisionaries/msg/f4acb49721b51834
#  could split files at known boundary to avoid the problem
#  2 bil / 22050 samples = 194783 seconds
#  = 54 hours.  Is that really our maximum?  Should be fine for all books... ?

# TODO: incorporate files_to_chapter_list for m4b files that must be broken up

####################################################
# ffmpeg output settings
output_bitrate="32000"
output_rate="22050"
output_channels="1"

# ffmpeg profiles
ffmpeg_output_profiles = {
        '.mp3': { 'codec': 'libmp3lame', 'format': 'mp3' },
        '.m4b': { 'codec': 'libfaac',    'format': 'mp4' },
        '.ogg': { 'codec': 'libvorbis',  'format': 'ogg' },
        }
#
####################################################

import sys
import os

def runOrDie(command):
    print "Running: " + command
    ret = os.system(command)
    if ret:
        print command + " failed"
        sys.exit(1)

def buildFilesString(files):
    ret = ""
    for f in files:
        ret += " '%s'" % f
    return ret

def filesToAudiobook(output, in_files):

    # Get output file extension
    output_extension = os.path.splitext(output)[1]

    if not ffmpeg_output_profiles.has_key(output_extension):
        print "Unknown file extension: " + output_extension
        sys.exit(1)

    # Pick ffmpeg output parameters based on output filetype
    output_codec = ffmpeg_output_profiles[output_extension]['codec']
    output_format = ffmpeg_output_profiles[output_extension]['format']

    # Command to loop through all the input files and output to stdout
    #  Use the output rate and channels to cut down on conversions
    #  (note: a fifo was attempted, but the fifo would randomly close prematurely)
    intermediate_format_options = "-ar %s -ac %s -f s16le" % (output_rate, output_channels)
    player_command = "for i in %s ; do ffmpeg -y %s /dev/stdout -i \"$i\" ; done""" % (buildFilesString(in_files), intermediate_format_options)

    # Now run the command to convert all data coming from stdin
    output_format_options = "-acodec %s -ar %s -ab %s -ac %s -f %s" % (output_codec, output_rate, output_bitrate, output_channels, output_format)
    runOrDie("( %s ) | ffmpeg -y %s -i /dev/stdin %s '%s'" % (player_command, intermediate_format_options, output_format_options, output))

if __name__ == "__main__":

    try:
        (output) = sys.argv[1]
        in_files = sys.argv[2:]
    except:
        print ""
        print "Usage: files_to_audiobook <outfile.[mp3|m4b|ogg]> <ffmpeg supported input files>"
        print ""
        print " Example:  files_to_audiobook AudioBook.mp3 ../*.mp3"
        print ""
        sys.exit(1)

    filesToAudiobook(output, in_files)
